{"meta":{"title":"铿锵小顺的博客","subtitle":"雨天出太阳","description":"Clang Shun的博客，学习只要够专一、努力，那么一定会成功","author":"Shun","url":"http://yoursite.com","root":"/"},"pages":[{"title":"search","date":"2019-12-31T03:02:19.000Z","updated":"2019-12-31T03:02:19.733Z","comments":true,"path":"search/index-1.html","permalink":"http://yoursite.com/search/index-1.html","excerpt":"","text":""},{"title":"search","date":"2019-12-31T03:02:03.000Z","updated":"2019-12-31T03:02:03.831Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"about","date":"2019-12-31T03:06:12.000Z","updated":"2019-12-31T03:06:13.013Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"在阿里云Centos云服务器上部署mysql数据库","slug":"在阿里云Centos云服务器上部署mysql数据库","date":"2019-11-28T14:27:38.740Z","updated":"2019-12-31T04:09:59.372Z","comments":true,"path":"2019/11/28/在阿里云Centos云服务器上部署mysql数据库/","link":"","permalink":"http://yoursite.com/2019/11/28/%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91Centos%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"layout: article title: 在阿里云Centos云服务器上部署mysql数据库date: 2018-4-23 在阿里云Centos云服务器上部署mysql数据库 首先查看centos7上有没有安装过mysql ,一定要卸载干净残留，不然会安装或启动失败。 12yum list installed mysql*列出后如果有就删除 删除mysql 123sudo yum remove mysql-community-*rm -rf /var/lib/mysqlrm /etc/my.cnf 安装yum源 12wget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpmsudo yum instal mysql80-community-release-el7-1.noarch.rpm 查看是否安装成功 sudo yum repolist all|grep mysql 成功安装 配置要安装的mysql版本 sudo vim /etc/yum.repos.d/mysql-community.repo enabled 为1表示启用，将要安装的版本的enabled改为1后保存 配置repo 安装启动mysqlsudo yum install mysql-community-server.x86_64 等待安装好后启动mysql 123sudo service mysqld start //启动mysqlsudo service mysqld status //查看mysql状态sudo systemctl enable mysqld //配置开机启动 管理账户 mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改： 123grep &apos;temporary password&apos; /var/log/mysqld.log //找到默认密码mysql -uroot -p set password for &apos;root&apos;@&apos;localhost&apos;=password(&apos;NEWPASSWORD&apos;); 或者ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;NEWPASSWORD&apos;; // 修改密码,注意密码要复杂一些，否则会不能通过。 添加远程用户 1GRANT ALL PRIVILEGES ON *.* TO &apos;username&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos; WITH GRANT OPTION; 查看并修改编码 mysql -u root -pshow variables like &#39;%char%;看到有的编码不是 utf8更改配置文件vim /etc/my.cnf在[mysqld]下面添加以下两句 character_set_server=utf8collation-server=utf8_general_ci在[client]下面添加default-character-set=utf8 修改成功 注意修改后只会对以后创建的数据库生效。 然后登陆阿里云配置安全组 通过实例列表选中服务器后，进入实例详情页面 在左侧点击本实例安全组 在安全组列表里选中你的服务器实例 页面默认会在安全组规则分页中 如图所示 )) 这样配置应该就会成功了","categories":[],"tags":[]},{"title":"微信小程序-注册整体过程","slug":"微信小程序-注册整体过程","date":"2019-04-07T16:00:00.000Z","updated":"2019-12-31T04:07:31.248Z","comments":true,"path":"2019/04/08/微信小程序-注册整体过程/","link":"","permalink":"http://yoursite.com/2019/04/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%B3%A8%E5%86%8C%E6%95%B4%E4%BD%93%E8%BF%87%E7%A8%8B/","excerpt":"","text":"微信小程序-注册整体过程reg.wxml 12345678910111213&lt;view&gt; &lt;view class=&quot;row&quot;&gt; # &lt;input class=&quot;info-input&quot; placeholder=&quot;请输入用户名&quot; bindinput=&quot;name&quot;&gt;&lt;/input&gt; &lt;input class=&quot;info-input&quot; placeholder=&quot;请输入用户名&quot; bindchange=&quot;name&quot;&gt;&lt;/input&gt; &lt;/view&gt; &lt;view class=&apos;row&apos;&gt; &lt;view class=&apos;info&apos;&gt; #&lt;input class=&quot;info-input&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; bindinput=&quot;password&quot;&gt;&lt;/input&gt; &lt;input class=&quot;info-input&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; bindchange=&quot;password&quot;&gt;&lt;/input&gt; &lt;/view&gt; &lt;/view&gt; &lt;button class=&quot;submit&quot; bindtap=&quot;reg&quot;&gt;注册&lt;/button&gt;&lt;/view&gt; reg.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// miniprogram/pages/reg/reg.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; name: &apos;&apos;, password: &apos;&apos; &#125;, //获取用户输入的用户名 name: function (n) &#123; // debugger var content = n.detail.value this.setData(&#123; name: content, &#125;) &#125;, //获取用户输入的密码 password: function (e) &#123; var pwd = e.detail.value; this.setData(&#123; password: pwd, &#125;) &#125;, # 绑定的点击事件 reg: function () &#123; // debugger console.log(this.data) wx.request(&#123; url: &apos;http://127.0.0.1:8000/app/reg/&apos;, method: &apos;post&apos;, data: &#123; &apos;name&apos;: this.data.name, &apos;password&apos;: this.data.password &#125;, header: &#123; // &apos;content-type&apos;: &apos;application/json&apos; //get 方式 &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125;, success: function (res) &#123; if(res.data.code==200)&#123; console.log(res) &#125;else&#123; console.log(res) &#125; &#125; &#125;) &#125; Django后台接口 12345678910111213141516171819202122232425#注册class reg(APIView): def post(self,request): # 获取用户名 密码 name=request.data[&quot;name&quot;] password=request.data[&quot;password&quot;] if not all([name,password]): return Response(&#123; &quot;code&quot;:201, &quot;message&quot;:&quot;请输入完整&quot; &#125;) # 判断数据库的账号是否存在 user=User.objects.filter(name=name).first() if user: return Response(&#123; &quot;code&quot;: 202, &quot;message&quot;: &quot;账号已存在&quot; &#125;) else: # 否则添加到数据库 User.objects.create(name=name,password=password) return Response(&#123; &quot;code&quot;: 200, &quot;message&quot;: &quot;注册成功&quot; &#125;)","categories":[],"tags":[]},{"title":"微信小程序获取用户信息以及用户的openid","slug":"微信小程序获取用户信息以及用户的openid","date":"2019-04-07T12:44:00.000Z","updated":"2019-12-31T04:04:57.243Z","comments":true,"path":"2019/04/07/微信小程序获取用户信息以及用户的openid/","link":"","permalink":"http://yoursite.com/2019/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%88%B7%E7%9A%84openid/","excerpt":"","text":"微信小程序获取用户信息以及用户的openid 在微信开发者工具新创建一个项目时，新项目的示例中已有如何获取用户基本信息的例子，此处不再赘述 重点是用户openid的获取 首先，这里需要两个参数，这个小程序的appId，以及在微信公众平台生成的本小程序的appsecret码，这里需要先登录微信公众平台的小程序模块 （1） （2） （3） 之后再微信开发者工具中，对调用的方法进行编辑，这里要用到微信官网API中的wx.login函数 ① 首先自定义一个函数，如我上图定义的getOpenId，在函数中调用wx.login方法，这个方法不需要传递参数，直接可以得到返回值，所以下一步直接通过success获得返回值，这个返回值返回的有一部分是用户登录后的一个密钥，如果要获取用户的openid会用到 ②在success中再次调用微信的一个方法wx.request，这个方法几乎等同于ajax和axios，传递的参数也是一样的，如图，将wx.login获取到的code值，小程序的appid和appsecret都作为参数传递到后台自己定义的接口中 ③后台接口如下图： 这里将这个url贴过来 1url = r&quot;https://api.weixin.qq.com/sns/jscode2session?appid=%s&amp;secret=%s&amp;js_code=%s&amp;grant_type=authorization_code&quot; % (appid, secret, code) 这里需要注意的是要用到requests库来发送请求 ④一切顺利的话返回的数据是这样的，也就是得到了用户的openid，而那个session_key则是用来判断用户登陆状态的，之后会另写一个文档介绍这个 如果返回的不是这样的，那就是出问题了，原因可能有两种： ​ ⑴ wx.login返回的code值被多次调用了： ​ 具体还不知道是哪里有问题，这样的报错可以自行百度 ​ ⑵ appid或者appsecret有误： ​ 这样的报错极有可能是在创建新项目的时候appid被替换了，需要给这个项目替换上微信公众平台上的appid，并重置一个appsecret再来试试","categories":[],"tags":[]},{"title":"微信小程序代码规范","slug":"微信小程序代码规范","date":"2019-04-07T10:44:00.000Z","updated":"2019-12-31T04:02:08.172Z","comments":true,"path":"2019/04/07/微信小程序代码规范/","link":"","permalink":"http://yoursite.com/2019/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"","text":"微信小程序里的四种文件1234.json 后缀的 JSON 配置文件.wxml 后缀的 WXML 模板文件.wxss 后缀的 WXSS 样式文件.js 后缀的 JS 脚本逻辑文件 资源管理12345678910111213### 图片资源目前图片资源的主要性能问题在于大图片和长列表图片上，这两种情况都有可能导致 iOS 客户端内存占用上升，从而触发系统回收小程序页面。### 图片对内存的影响在 iOS 上，小程序的页面是由多个 WKWebView 组成的，在系统内存紧张时，会回收掉一部分 WKWebView。从过去我们分析的案例来看，大图片和长列表图片的使用会引起 WKWebView 的回收。### 图片对页面切换的影响除了内存问题外，大图片也会造成页面切换的卡顿。我们分析过的案例中，有一部分小程序会在页面中引用大图片，在页面后退切换中会出现掉帧卡顿的情况。当前我们建议开发者尽量减少使用大图片资源。 资源文件123456所有资源文件(如图片)放在统一文件下及其子文件中(例如以下分类)resource ——public ——tab ——home ——mine 基础页面1234567891011121314151617业务展示的页面放在如 pages 文件及其子文件中(例如以下分类)pages ——index ——mall ——goodList ——goodDetail ——order ——orderList ——orderDetail ——mine ——myInfo ——myAddress 如有其他子业务，单独在pages里创建新的子级文件注释规范 针对wxml页面由上到下(或由左到右)分级的模块，均需注释出其功能， 并在其上下空出一行与其他代码进行区分。 样式文件12345678910111213141516171819202122232425基础样式文件，在最外层中创建(如：weui.wxss)第一步：写入公共样式：如 1.标题字体大小，描述字体大小等项目中一二三级字号；2.程序中所用的公共色值；3.布局方式flex的横向布局，纵向布局等；4.公共布局中wxss样式前缀统一(如weui-开头)；等等第二步：在app.wxss文件最上部，引入 @import \"weui.wxss\";以上公共样式便可全局使用wxss规范 1.wxss 页面可使用快捷键真理代码(Shift+Alt+F) 整理后代码有明显的代码缩进，对齐。每一个样式类之间空出一行； 2.在开发过程中rpx和px均可能用到， 如通常情况下间距使用rpx， 字体大小和边框等使用px，开发者根据实际情况而定； 3.同一块的样式属性(如 .order-title 和 .order-image)放在一块； 4.wxss 样式中同一块可以这样抒写(如 .order.title) 意思是.order样式下的.title, 其他地方的class='title'不会引用到.order下的.title 5.wxss样式之间用块状注释。请勿在代码后面直接注释。 JS规范12345678910JS规范 1.删除js文件中未用到的生命周期函数，保持代码的整洁 2.右上角不要分享的页面，删除JS文件中该方法onShareAppMessage:function() 3.采用ES6 关键字let定义变量，尽量不使用var 4.所有涉及到数据绑定的变量均需在data中初始化,禁止在不定义的情况下直接setData 5.变量名以及函数名统一采用驼峰命名法(或下划线分割) 6.正常情况下函数名前缀需加上清晰的动词表示函数功能(如getOderList) 7.点击事件函数命名方式为 on + 事件名 或者业务名 8.JS语句无需以分号结束，统一省略分号 9.JS中一致使用单引号' ' , WXML中一致使用双引号\" \" ES6一个ES6的模块是一个包含了js代码的文件。ES6里没有所谓的module关键字，一个模块就是一个普通的脚本文件，除了以下两个区别： \\1. ES6中的模块自动开启严格模式。\\2. 模块中可以使用import和export。 导入和导出 我们可以通过import和export关键字将函数或对象导入和导出模块。先来说说export，在模块中声明的任何东西都是默认私有的，如果想对其他模块public，必须将那部分代码export。最简单的方法就是添加一个export关键字： 1`// kittydar.js``export ``function` `detectCats(canvas, options) &#123;``var` `kittydar = ``new` `Kittydar(options);``return` `kittydar.detectCats(canvas);``&#125;``export class Kittydar &#123;``... several methods doing image processing ...``&#125;``// This helper function isn't exported.``function` `resizeCanvas() &#123;``...``&#125;``...` 不再有跨文件或跨模块的全局变量，export声明的那部分就是这个模块的public API。而在另外一个文件中，我们可以导入这个模块并且使用detectCat方法： 1`// demo.js - Kittydar demo program``import &#123;detectCats&#125; from ``\"kittydar.js\"``;``function` `go() &#123;``var` `canvas = document.getElementById(``\"catpix\"``);``var` `cats = detectCats(canvas);``drawRectangles(canvas, cats);``&#125;` 如果需要导入多个模块中的接口，如下： 1`import &#123;detectCats, Kittydar&#125; from ``\"kittydar.js\"``;` 我们也可以通过一行代码将本模块所有需要public的方法公开： 1`export &#123;detectCats, Kittydar&#125;;` 这样就不用一个个地添加export关键字了。 命名冲突 上面介绍了模块中的导入和导出，那么如果导入的变量名和模块中的变量名冲突了应该如何是好呢？放心，ES6允许我们为导入的内容重命名： 1`import &#123;flip as flipOmelet&#125; from ``\"eggs.js\"``;``import &#123;flip as flipHouse&#125; from ``\"real-estate.js\"``;` 这样就将从eggs模块来的flip改为了flipOmelet，从real-estate模块来的flip改为了flipHouse，从而避免了冲突。 同样的，我们也可以在模块导出变量名时进行重命名： 1`function` `v1() &#123; ... &#125;``function` `v2() &#123; ... &#125;``export &#123;``v1 as streamV1,``v2 as streamV2,``v2 as streamLatestVersion``&#125;;`","categories":[],"tags":[]},{"title":"flask-socketio","slug":"flask-socketio","date":"2018-12-08T16:00:00.000Z","updated":"2019-12-31T04:21:04.797Z","comments":true,"path":"2018/12/09/flask-socketio/","link":"","permalink":"http://yoursite.com/2018/12/09/flask-socketio/","excerpt":"","text":"flask-socketio Installation(安装) Requirements(依赖) Initialization(初始化) Receiving Messages(接收消息) == Sending Messages(发送消息) Broadcasting(广播) Rooms(房间) Connection Events(连接事件) Class-Based Namespaces(基于类的命名空间) Error Handling Access to Flask’s Context Globals(访问Flask的全局上下文) Authentication(验证) 使用带有Flask-SocketIO的Flask-Login Deployment(部署) Using nginx as a WebSocket Reverse Proxy(使用nginx作为WebSocket反向代理) TODO Using Multiple Workers(使用多个工作者) Emitting from an External Process 参考资料 flask-socketioFlask-SocketIO 给Flask应用提供了客户端和服务端低延时双向通信。客户端这边应用程序可以使用Javascript，C++，Java，Swift的官方SocketIO库,或者兼容客户端向服务端建立一个持久链接的编程语言中任意一个官方[[http://socket.io/|SocketIO]]库。 Installation(安装)pip install flask-socketio Requirements(依赖)Flask-SocketIO兼容python2.7和python3.3+。Flask-SocketIO包的异步服务依赖于以下三种选择: eventlet是最好的选择,支持长轮询和WebSocket传输 gevent支持不同的配置。长轮询在gevent包里被完全支持,但是不像eventlet，gevent自己并不支持WebSocket。为了支持WebSocket当前有两个选择。安装gevent-websocket包和使用uWSGIweb服务，uWSGI提供WebSocket功能。gevent也是一个不错的选择，但是略低于eventlet。 基于Werkzeug的Flask开发服务也可以用，但是给出警告，它的性能低于前两个选择，所以它应该被用于开发中。这个选项只支持长轮训传输。 采用哪个异步框架取决于本机安装了什么。优先使用eventlet，gevent次之。对于gevent中支持WebScket， uWSGI优先，gevent-websocket次之。如果既没有eventlet也没有gevent安装，那么使用Flask开发服务。 如果使用多进程，消息队列服务将被用于协调操作，例如广播。支持的队列有Redis,RabbitMQ,和任意支持Kombu包的消息队列。 客户端这边，官方的Socket.IO Javascript客户端库可以用来和服务端建立连接。这里也有些用Swift，Java，C++写的官方客户端。非官方客户端可能也能工作，只要实现了Socket.IO协议 Initialization(初始化)下面代码例子展示了如何在Flask应用中添加Flask-SocketIO： 123456789from flask import Flask, render_templatefrom flask_socketio imoprt SocketIOapp = Flask(__name__)app.config['SECRET_KEY'] = 'secret!'socketio = SocketIO(app)if __name__ == '__main__': socketio.run(app) init_app()风格的初始化也是被支持的。注意这种方式中web服务被启动了。socketio.run()方法封装了web服务的启动并且替代了app.run()来启动Flask开发服务。当应用在debug模式Werkzeug开发服务将被使用并且是在socketio.run()来配置属性。在生产模式如果eventlet有效，eventlet web服务将被使用，否则使用gevent的。如果eventlet和gevent都没安装，将使用Werkzeug开发web服务。 Flask 0.11引入的”flask运行命令”可以用来启动基于Werkzeug的Flask-SocketIO开发服务，但是这种方式启动由于缺少对WebSocket支持而被不推荐。这个包（flask-socket）的之前版本包含了“flask运行命令”，允许使用eventlet和gevent的WebSocket生产服务。但是这个功能已经在上面展示的socketio.run(app)中停止了。 这个应用只能服务于客户端页面。客户端加载了Socket.IO库和建立连接。 1234567&lt;script type=\"text/javascript\" src=\"//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" charset=\"utf-8\"&gt; var socket = io.connect('http://' + document.domain + ':' + location.port); socket.on('connect', function() &#123; socket.emit('my event', &#123;data: 'I\\'m connected!'&#125;); &#125;);&lt;/script&gt; Receiving Messages(接收消息) ==当使用SocketIO，消息被事件的两端接收。客户端这边使用Javascript回调。使用Flask-SocketIO,服务端需要注册这些事件的处理，类似路由通过视图函数处理。 下面例子给一个无名事件创建服务端这边的事件处理函数： 123@socketio.on('message')def handle_message(message): print('received message: ' + message) 上线例子使用字符消息。另一个无名事件使用JSON数据: 123@socketio.on('json')def handle_json(json): print('received json:' + str(json)) 最灵活的事件类型是自定义事件名称。这些事件的消息数据可以是string,bytes，int或者JSON: 123@socketio.on('my event')def handle_my_custom_event(json): print('received json:' _ str(json)) 自定义名称事件也支持多参数： 123@socketio.on('my event')def handle_my_custom_event(args1, args2, args3): print('received args:' + args1 + args2 + args3) 命名事件是非常灵活的，因为它们不需要包括额外元数据来描述消息类型。Flask-SocketIO也支持SocketIO命名空间，命名空间允许客户端通过多个不同独立连接在同一个物理socket上： 123@socketio.on('my event', namespace='/test')def handle_my_custom_namespace_event(json): print('receviced json:' + str(json)) 当命名空间没有指定，默认全局命名空间’/‘将被使用。对于某些时候装饰器语法并不方便，on_event方法可以使用: 123def my_function_handler(darta): passsocketio.on_event('my event', my_function_handler, namespace='/test') 客户端要求服务端回复一个确认收到客户端发来消息的应答,处理函数返回的任何值都将传给客户端作为回调函数的参数： 1234@socketio.on('my event')def handle_my_custom_event(json): print('received json:' + str(json)) return 'one', 2 上面这个例子，客户端回调函数携带两个参数进行调用，’one’和2。如果处理函数没有任何返回值，客户端回调函数将不携带任何参数进行调用。 Sending Messages(发送消息)之前章节里定义的SocketIO事件处理函数可以通过send()和emit()函数发送回复消息给连接的客户端。 下面例子将收到的消息返回给发送过来的客户端： 12345678910111213from flask_socketio import send, emit@socketio.on('message')def handle_message(message): send(message) @socketio.on('json') def handle_json(json): send(json, json=True) @socketio.on('my event') def handle_my_custom_envent(json): emit('my response', json) 注意send()和emit()如何被用来分别给无名和命名事件发送消息的 当使用了命名空间，send()和emit()将默认使用发来消息的命名空间。可以通过指定可选参数namespace来给不同命名空间发送消息： 1234567@socketio.on('message')def handle_message(message): send(message, namespace='/chat')@socketio.on('my event')def handle_my_custom_event(json): emit('my response', json, namespace='/chat') 为了发送多个参数的事件，通过发送一个元组来实现： 123@socketio.on('my event')def handle_my_custom_event(json): emit('my response', ('foo', 'bar', json), namespace='/chat') 使用回调时，Javascript客户端根据收到的消息来调用回调函数。客户端应用执行回调函数之后服务端调用相应的服务端回调。如果客户端的回调携带参数调用，这些参数也将作为服务端回调的参数 Broadcasting(广播)另一个非常有用的SocketIO特性是消息广播。Flask-SocketIO通过send()和emit()中的可选参数broadcast=True来支持这个特性: 123@socketio.on('my event')def handle_my_custom_event(data): emit('my response', data, broadcast=True) 当broadcast选项为True情况下发送消息，所有连接同个命名空间的客户端连接将收到这个消息，包括发送者。没有指定命名空间时，连接到全局命名空间的客户端将受到消息。注意广播消息不会调用回调函数。 上面所有例子都建立在服务端收到客户端的事件，但是有些应用服务端需要是消息的发起者。这对实现服务端发送通知给客户端很有用，比如在后台线程中。socketio.send()和socketio.emit()方法可以对所有连接的客户端广播： 12def some_function(): socketio.emit('some event', &#123;'data': 42&#125;) 注意在上下文感知上，socketio.send()和socketio.emit()是不一样的函数。也要注意上面没有客户端上下文的用法,所以broadcast=True是假定的并且不需要特指。 Rooms(房间)对于很多应用对用户分组成子集并在子集中互相通信是必要的。很好的一个例子是多房间的聊天室，这里用户收到来自一个或多个他们进入的房间，但是不会收到另外房间的消息。Flask-SocketIO通过join_room()和leave_room()来支持房间概念: 123456789101112131415from flask_socketio import join_room, leave_room@socketio.on('join')def on_join(data): username = data['username'] room = data['room'] join_room(room) send(username + ' has entered the room.', room=room)@socketio.on('leave')def on_leave(data): username = data['username'] room = data['room'] leave_room(room) send(username + ' has left the room.', room=room) send()和emit()函数接受可选参数room来控制消息发送给指定room的所有用户。 所有客户端在连接时赋值一个房间，名字使用连接的session ID，通过request.sid获得。客户端可以加入任何房间，房间可以起任何名称。当客户端断开连接，它将从进入过的房间移除。上下文无关socketio.send()和socketio.emit()函数也同样接受room参数来对一个房间进行广播 由于所有客户端分配到个人房间，给单个客户端发消息，客户端的session ID可以用来做room参数 Connection Events(连接事件)Flask-SocketIO也派遣连接和断开连接事件。下面例子展示如何为它们注册处理函数: 1234567@socketio.on('connect', namespace='/chat')def test_connect(): emit('my response', &#123;'data': 'Connected'&#125;)@socketio.on('disconnect', namespace='/chat')def test_disconnect(): print('Client disconnected') connection事件处理函数可以返回False来拒绝连接，这里便于客户端在这里权限校验注意connection和disconnection事件在每个命名空间独立发送 Class-Based Namespaces(基于类的命名空间)一种是上面描述的基于装饰器的事件处理，另一种方式是创建类方法作为事件处理。flask_socketio.Namespace作为基类来创建一个基于类的命名空间： 12345678910from flask_socketio import Namespace, emitclass MyCustomNamespace(Namespace): def on_connect(self): pass def on_disconnect(self): pass def on_my_event(self, data): emit('my_response', data)socketio.on_namespace(MyCustomNamespace('/test')) 当基于类的命名空间被启用，任何被服务端收到的事件将派遣到方法名是以事件名加on_为前缀的方法中。举个例子，事件my_event将被方法名为on_my_event处理。如果收到一个事件在类命名空间中没有对应的方法，那么事件将被忽略。所有使用命名空间类的事件名必须使用方法名合法的字符。 [原文]As a convenience to methods defined in a class-based namespace, the namespace instance includes versions of several of the methods in the flask_socketio.SocketIO class that default to the proper namespace when the namespace argument is not given. 如果一个事件即有命名空间类的处理方法也有装饰器处理函数，那么只有装饰器处理函数被调用。 Error HandlingFlask-SocketIO也可以处理异常： 1234567891011@socketio.on_error() # Handles the default namespacedef error_handler(e): pass@socketio.on_error('/chat') # handles the '/chat' namespacedef error_handler_chat(e): pass@socketio.on_error_default # handles all namespaces without an explicit error handlerdef default_error_handler(e): pass 错误处理函数将异常对象作为一个参数 当前请求的消息和数据参数可以通过request.event变量来检查，这有利于外部活动处理函数的错误日志和调试: 12345678910from flask import request@socketio.on(\"my error event\")def on_my_event(data): raise RuntimeError()@socketio.on_error_defaultdef default_error_handler(e): print(request.event[\"message\"]) # \"my error event\" print(request.event[\"args\"]) # (data,) Access to Flask’s Context Globals(访问Flask的全局上下文)SocketIO事件处理函数不同于路由处理函数，这里介绍SocketIO处理函数中在哪些能做哪些不能做中容易混淆的东西。最主要的不同是所有SocketIO事件发生在单个长期运行的上下文请求之中。 尽管不同，但Flask-SocketIO尝试使SocketIO事件处理和常规HTTP请求的环境相似。下面描述了哪些还能正常工作，哪些不能了： 在事件处理函数之前,应用上下文被压入（保存在数据结构中）使得current_app和g可以在处理函数中可用。 在调用处理函数之前请求上下文也被压入，同样使得request和session可用。但是注意WebSocket事件没有与之相关联的请求，所以对于在存活的连接中所有被派遣的事件请求上下文是在开始连接的时候被压入。 请求上下文(全局变量request)被连接产生的唯一session ID设置的sid变量所增强(request全局变量里增加了sid,http请求中是没有sid的)。这个值被用来初始化客户端加入的房间(room)。 请求上下文被含有命名空间和事件参数的namespace和event成员所增强(request中增加了namespace和event变量)。event成员是一个含有message和args的字典。 全局上下文变量session行为和常规的请求不一样。在SocketIO建立使处理函数在连接上下文中被调用的时候用户session被拷贝了一份。如果SocketIO处理函数修改了session，被修改的session变量将会被后续SocketIO处理函数有效，但是常规HTTP路由的处理函数看不到修改的变化。实际上，当SocketIO处理函数修改session，session的副本将被创建用于这些处理函数。这种限制的技术原因是，为了保存用户会话，需要将cookie发送到客户机，这需要HTTP请求和响应，而SocketIO连接中不存在这样的请求和响应。当使用诸如Flask-Session或Flask-KVSession扩展提供的服务器端会话时，只要会话没有在SocketIO处理程序中修改，SocketIO处理程序就可以看到HTTP路由处理程序中对会话所做的更改。 before_request和after_request钩子在SocketIO事件处理中无效。 SocketIO处理函数可以使用自定义的装饰器，但是许多Flask装饰器不能用在SocketIO处理函数上，在SocketIO连接中没有响应对象这个概念。 Authentication(验证)应用的共同需要就是验证他们用户的身份。自从SocketIO没有使用HTTP请求和应答，传统的基于网页表单和HTTP请求的机制不能用于SocketIO连接。如果需要的话，应用可以实施自定义的登陆表单，当用户按下提交按钮时，它利用一个SocketIO消息将证书发送到服务器。 然而，在大多数情况下，在SocketIO连接建立之前使用传统的身份验证方式会更加方便，用户的身份信息可以被记录下来作为用户会话或者cookie，之后在SocketIO连接建立起来的时候，这些信息也可以被SocketIO活动处理器得到。 使用带有Flask-SocketIO的Flask-LoginFlask-SocketIO可以访问被Flask-Login维护的登录信息。Flask-Login鉴定执行和login_user()函数调用来在用户session中记录用户后，任何SocketIO连接将可以访问current_user上下文比变量: 12345678@socketio.on('connect')def connect_handler(): if current_user.is_authenticated: emit('my response', &#123;'message': '&#123;0&#125; has joined'.format(current_user.name)&#125;, broadcast=True) else: return False # not allowed here 注意login_required装饰器不能用于SocketIO事件处理器,但是自定义一个无权限断开连接的装饰器如下: 12345678910111213141516171819import functoolsfrom flask import requestfrom flask_login import current_userfrom flask_socketio import disconnectdef authenticated_only(f): @functools.wraps(f) def wrapped(*args, **kwargs): if not current_user.is_authenticated: disconnect() else: return f(*args, **kwargs) return wrapped@socketio.on('my event')@authenticated_onlydef handle_my_custom_event(data): emit('my response', &#123;'message': '&#123;0&#125; has joined'.format(current_user.name)&#125;, broadcast=True) Deployment(部署)Using nginx as a WebSocket Reverse Proxy(使用nginx作为WebSocket反向代理)TODOUsing Multiple Workers(使用多个工作者)Flask-SocketIO从2.0版本开始在负载均衡器后面支持多个Worker(工作者).部署多个worker给Flask-SocketIO应用有能力在多个进程和主机上传播客户端连接,也因此可以支持更多的客户端并发。 使用多工作者模式需要两个依赖: 负载均衡器必须被配置成从一个客户端来的所有HTTP请求发送到同一个worker处理。这个有时被称为”sticky sessions”。对于nginx，用ip_hash直接实现会话保持。Gunicorn不能被用于多个工作者，因为它的负载均衡算法不支持粘滞会话(sticky sessions)。 因为每一个server只拥有客户端连接的子集，所以例如Redis或者RabbitMQ这样的消息队列被用来协同一些操作，例如broadcasting(广播)和rooms。（译者注：这个应该好理解，多个worker部署在不同机器上，就有可能一个room的连接分布在不同机器上，如果要对房间内得人进行广播，那么必然要有个介质用来协调）。 当在消息队列下工作就需要安装下面这些依赖: 对于Redis，redis包必须安装(pip install redis). 对于RabbitMQ,kombu包必须安装(pip install kombu) 对于其它支持Kombu的消息队列，查看Kombu documentation来确定依赖什么 如果消息队列用到eventlet或者gevent,那么通常也需要python标准库的猴子补丁来让消息队列包工作 为了让Flask-SocketIO服务器们跑起来，你必须首先确保有个消息队列跑起来。为了让Socket.IO服务器跑起来并且连接上消息队列，需要SocketIO构造器中增加一个message_queue参数：socketio = SocketIO(app, message_queue=&#39;redis://&#39;)message_queue参数值是你使用的消息队列URL连接。如果redis消息队列和服务跑在同一个主机上，可以使用’redis://‘URL。同样的，RabbitMQ队列使用’amqp://‘。Kombu包里的文档有描述它支持的队列URL格式。 Emitting from an External Process参考资料[[https://www.jianshu.com/p/d81397edd2b1]] [[https://flask-socketio.readthedocs.io/en/latest/]]","categories":[],"tags":[]},{"title":"CentOS 7 安装 python3 v1.1","slug":"CentOS 7 安装 python3 v1.1","date":"2018-11-18T16:00:00.000Z","updated":"2019-12-31T04:19:27.718Z","comments":true,"path":"2018/11/19/CentOS 7 安装 python3 v1.1/","link":"","permalink":"http://yoursite.com/2018/11/19/CentOS%207%20%E5%AE%89%E8%A3%85%20python3%20v1.1/","excerpt":"","text":"CentOS 7 安装 python3 CentOS 7 自带的python为python2.7版本，yum等包依赖于python2，不可以直接卸载。需要下载python3的源码后自行编译安装。以下是安装步骤 1. 安装用于编译python源码的依赖包1yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc* make -y 2. 安装下载源码的工具12pip install wget# 由于还没有python3，这里的wget是安装到了python2.7中 3. 下载python源码1wget https://www.python.org/ftp/python/3.7.5/Python-3.7.5.tar.xz 4. 编译1234567# 解压tar -xvJf Python-3.7.5.tar.xz# 进入解压后的目录，配置安装路径./configure prefix=/usr/local/python3# 编译安装make &amp;&amp; make install 5. 添加软链接12345678# 添加python3的软链接ln -s /usr/local/python3/bin/python3 /usr/bin/python3# 添加pip3的软连接ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3#测试是否安装成功了python3 -V python指向的是python2，python2指向的是python2.7，在装完python3后，将python指向python3，然后python2指向python2.7，那么两个版本的python就能共存了 12345vi /usr/bin/yum把#! /usr/bin/python修改为#! /usr/bin/python2vi /usr/libexec/urlgrabber-ext-down把#! /usr/bin/python 修改为#! /usr/bin/python2","categories":[],"tags":[]},{"title":"supervisor介绍","slug":"supervisor介绍","date":"2018-05-25T16:00:00.000Z","updated":"2019-12-31T04:20:09.923Z","comments":true,"path":"2018/05/26/supervisor介绍/","link":"","permalink":"http://yoursite.com/2018/05/26/supervisor%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"supervisor介绍一、supervisor简介Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。 二、supervisor安装 配置好yum源后，可以直接安装 1yum install supervisor Debian/Ubuntu可通过apt安装 1apt-get install supervisor pip安装 1pip install supervisor easy_install安装 1easy_install supervisor 三、supervisor使用supervisor配置文件：/etc/supervisord.conf1*注：supervisor的配置文件默认是不全的，不过在大部分默认的情况下，上面说的基本功能已经满足。* 子进程配置文件路径：/etc/supervisord.d/1*注：默认子进程配置文件为ini格式，可在supervisor主配置文件中修改。* 四、配置文件说明supervisor.conf配置文件说明：1234567891011121314151617181920212223242526272829303132333435363738394041424344[unix_http_server]file=/tmp/supervisor.sock ;UNIX socket 文件，supervisorctl 会使用;chmod=0700 ;socket文件的mode，默认是0700;chown=nobody:nogroup ;socket文件的owner，格式：uid:gid ;[inet_http_server] ;HTTP服务器，提供web管理界面;port=127.0.0.1:9001 ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性;username=user ;登录管理后台的用户名;password=123 ;登录管理后台的密码 [supervisord]logfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.loglogfile_maxbytes=50MB ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小logfile_backups=10 ;日志文件保留备份数量默认10，设为0表示不备份loglevel=info ;日志级别，默认info，其它: debug,warn,tracepidfile=/tmp/supervisord.pid ;pid 文件nodaemon=false ;是否在前台启动，默认是false，即以 daemon 的方式启动minfds=1024 ;可以打开的文件描述符的最小值，默认 1024minprocs=200 ;可以打开的进程数的最小值，默认 200 [supervisorctl]serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord ; [program:xx]是被管理的进程配置参数，xx是进程的名称[program:xx]command=/opt/apache-tomcat-8.0.35/bin/catalina.sh run ; 程序启动命令autostart=true ; 在supervisord启动的时候也自动启动startsecs=10 ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒autorestart=true ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启startretries=3 ; 启动失败自动重试次数，默认是3user=tomcat ; 用哪个用户启动进程，默认是rootpriority=999 ; 进程启动优先级，默认999，值小的优先启动redirect_stderr=true ; 把stderr重定向到stdout，默认falsestdout_logfile_maxbytes=20MB ; stdout 日志文件大小，默认50MBstdout_logfile_backups = 20 ; stdout 日志文件备份数，默认是10; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.outstopasgroup=false ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程killasgroup=false ;默认为false，向进程组发送kill信号，包括子进程 ;包含其它配置文件[include]files = relative/directory/*.ini ;可以指定一个或多个以.ini结束的配置文件 子进程配置文件说明：给需要管理的子进程(程序)编写一个配置文件，放在/etc/supervisor.d/目录下，以.ini作为扩展名（每个进程的配置文件都可以单独分拆也可以把相关的脚本放一起）。如任意定义一个和脚本相关的项目名称的选项组（/etc/supervisord.d/test.conf）： 1234567891011121314151617181920212223242526#项目名[program:blog]#脚本目录directory=/opt/bin#脚本执行命令command=/usr/bin/python /opt/bin/test.py#supervisor启动的时候是否随着同时启动，默认Trueautostart=true#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的autorestart=false#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1startsecs=1#脚本运行的用户身份 user = test#日志输出 stderr_logfile=/tmp/blog_stderr.log stdout_logfile=/tmp/blog_stdout.log #把stderr重定向到stdout，默认 falseredirect_stderr = true#stdout日志文件大小，默认 50MBstdout_logfile_maxbytes = 20M#stdout日志文件备份数stdout_logfile_backups = 20 子进程配置示例：123456789#说明同上[program:test] directory=/opt/bin command=/opt/bin/testautostart=true autorestart=false stderr_logfile=/tmp/test_stderr.log stdout_logfile=/tmp/test_stdout.log #user = test 五、supervisor命令说明常用命令123456supervisorctl status //查看所有进程的状态supervisorctl stop es //停止essupervisorctl start es //启动essupervisorctl restart //重启essupervisorctl update //配置文件修改后使用该命令加载新的配置supervisorctl reload //重新启动配置中的所有程序 注：把es换成all可以管理配置中的所有进程。直接输入supervisorctl进入supervisorctl的shell交互界面，此时上面的命令不带supervisorctl可直接使用。 注意事项使用supervisor进程管理命令之前先启动supervisord，否则程序报错。 使用命令supervisord -c /etc/supervisord.conf启动。 若是centos7： 12systemctl start supervisord.service //启动supervisor并加载默认配置文件systemctl enable supervisord.service //将supervisor加入开机启动项","categories":[],"tags":[]},{"title":"选择在Linux下安装redis","slug":"选择在Linux下安装redis","date":"2018-04-18T16:00:00.000Z","updated":"2019-12-31T04:08:55.575Z","comments":true,"path":"2018/04/19/选择在Linux下安装redis/","link":"","permalink":"http://yoursite.com/2018/04/19/%E9%80%89%E6%8B%A9%E5%9C%A8Linux%E4%B8%8B%E5%AE%89%E8%A3%85redis/","excerpt":"","text":"选择在Linux下安装redis， 1.安装gcc redis是c语言编写的 yum install gcc-c++2.下载redis安装包,在root目录下执行 wget http://download.redis.io/releases/redis-5.0.4.tar.gz3.解压redis安装包 1tar -zxvf redis-5.0.4.tar.gz 4.进入redis目录 1cd redis-5.0.4 5.编译 1make 6.安装 1make PREFIX=/usr/local/redis install 7.拷贝redis.conf到安装目录 1cp redis.conf /usr/local/redis 8.进入 /usr/local/redis目录 1cd /usr/local/redis/ 9.编辑redis.conf vim redis.conf 1.后台启动，daemonize yes 2.绑定端口，port 6379 默认是6379 需要安全组开放端口 3.绑定IP，bind 127.0.0.1:默认的 4.指定数据存放路径，dir /usr/local/redis/log存放的路径 5.指定持久化方式，appendonly yes 6.requirepass redis129 设置密码 10.后端启动redis： ./bin/redis-server ./redis.conf11.查看是否启动成功： ps aux | grep redis12.杀死redis并重新启动redis: 12pkill -9 redis-server./bin/redis-server ./redis.conf 13.检测是否开启 1ps axu | grep redis-server 14.客户端远程通过ip连接redis 1bin/redis-cli -h 127.0.0.1 -p 6379 如果出现如下，就是代表连接成功 1127.0.0.1:6379&gt;","categories":[],"tags":[]},{"title":"使用Hexo搭建自己的个人博客","slug":"使用Hexo搭建自己的个人博客","date":"2018-04-18T16:00:00.000Z","updated":"2019-12-31T04:22:09.426Z","comments":true,"path":"2018/04/19/使用Hexo搭建自己的个人博客/","link":"","permalink":"http://yoursite.com/2018/04/19/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"使用Hexo搭建自己的个人博客从零开始搭建自己的静态博客前提摘要 可能不需要会写多少代码，会照葫芦画瓢对一些地方进行修改就好。 安装node.js npm 了解基础知识 个人觉得不了解好像也没什么问题，跟着装就好了。然后就了解了啊。 安装git 可以不知道git是什么 hexo配合github搭建博客会用到四个常用的命令 到时候掌握了这四个命令的作用就行了 有一个github账号 和其他账号的注册没有什么区别。用github作为服务器使用。 注册地址：github地址 会markdown就好，不会也没关系，现学也可以很快掌握。 推荐markdown编辑器：typora 一、环境搭建1.1 安装node.js下载地址如下：node.js下载 下载自己所需要的版本，与安装普通软件没有任何区别。 安装node.js 检查一下是否安装成功 windows系统下快捷键win+r 输入cmd 打开终端 在终端输入 npm -v 显示版本号则为安装成功 版本号不用和我的一样 1.2 安装git下载地址及安装方法如下：git安装 安装地址和方法这里都有说了 git安装 过程 https://blog.csdn.net/qq_41782425/article/details/85183250 若是安装成功 鼠标右键会出现这俩图表 git安装 1这两个是必备的工具 一定要安装上才行 二、创建库2.1注册gitbub账号本来不想从注册开始写的…然后想了想不能做一个标题党，所以真的从零开始哦。 ① 输入地址 点击注册 github注册地址 ② 填写表单 填写表单 ③ 继续 账号也就有了 注册 2.2 建立仓库① 新建项目 新建项目 ② 上邮箱里验证一下 验证 ③新建项目 新建一个名为你的用户名.github.io的仓库，例如，你的github用户名为user，就新建一个名为user.github.io的仓库（强制要求哦），将来你的网站访问地址就为：http://user.github.io 并且一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 项目命名 2.4 配置SSH KEY我们到时候会把本地的代码提交到github上，这一步就是配置权限，解决本地和服务器的链接问题 ① 鼠标右键git bash here 配置步骤1 ②打开git bash，就是一个linux命令窗口 配置步骤2 ③创建SSH keys 在bash中输入 1ssh-keygen -t rsa -C &quot;shaoshanhuan@163.com&quot; 然后无脑回车~ 配置成功 ④复制keys 进入生成的ssh目录 : C:\\users(中文是用户)\\你电脑的用户名 .ssh 中, 使用记事本打开 id_rsa.pub 文件, 将该文件中的内容复制 复制keys ⑤复制id_rsa.pub里面的内容 id_rsa.pub ⑥将复制的内容粘进github 有些网页看不懂可以全页翻译 配置1 配置2 配置3 前面加 $ 的都是在 git bash 里面 运行的，不要把 黑窗口和 git bash 搞混淆了 ⑦测试是否成功 1$ ssh -T git@github.com 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi ***! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 此时你还需要配置： 12$ git config --global user.name \"***\"// 你的github用户名，非昵称$ git config --global user.email \"xxx@qq.com\"// 填写你的github注册邮箱 三、 初始化工程3.1 全局安装hexo① 全局安装hexo 打开终端输入命令： 1npm install hexo-cli -g ②创建hexo项目 在你认为合适的地方新建文件夹，我将其放在d盘新建文件夹命名为hexo 终端切换到这个目录，执行以下命令为： 123456$ cd d:/hexo // 这个命令表示终端切换到d盘hexo目录下$ hexo init blog // 初始化项目 项目名称为blog 这个过程可能会花费一些时间$ cd blog // 切换到blog目录下$ npm install // 这一步是安装所需的依赖$ hexo g # 或者hexo generate //生成静态文件$ hexo s # 或者hexo server //然后就可以在浏览器输入http://localhost:4000/ 就可以在本地查看初始化的项目了 目录长这个样子： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes (1) 界面出不来的话可以试一试 http://localhost:4000// (2) 换一个 端口号 hexo server -p 5000 界面长这个样子： 初始化界面 3.2 下载并安装主题一般应该很少人直接使用默认的主题吧，毕竟不是很好看。 我用的主题叫做anisina，因为作者的文档确实写的不太全，所以当时研究主题反而花了很多时间。 我就在这里详细介绍一下我用的主题咋配的吧，大家可以上网搜hexo主题 应该可以找到很多，挑自己喜欢的就行 最好是好看文档又全的，可以省很多事情。 *①下载主题(更多主题下载处) * 打开终端在d:/hexo/bolg/themes目录下，输入如下命令下载主题 1git clone https://github.com/Haojen/hexo-theme-Anisina.git ②配置主题 (作者提供的api文档) 打开hexo/blog/_config.yml 文件 修改themes: Anisina 修改主题","categories":[],"tags":[]},{"title":"rabbitmq原理及基础概念","slug":"rabbitmq原理及基础概念","date":"2018-04-10T16:00:00.000Z","updated":"2019-12-31T04:17:11.309Z","comments":true,"path":"2018/04/11/rabbitmq原理及基础概念/","link":"","permalink":"http://yoursite.com/2018/04/11/rabbitmq%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","excerpt":"","text":"RabbitMQ简介AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。下面将重点介绍RabbitMQ中的一些基础概念，了解了这些概念，是使用好RabbitMQ的基础。 ConnectionFactory、Connection、ChannelConnectionFactory、Connection、Channel都是RabbitMQ对外提供的API中最基本的对象。Connection是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。ConnectionFactory为Connection的制造工厂。Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。 QueueQueue（队列）是RabbitMQ的内部对象，用于存储消息，用下图表示。 RabbitMQ中的消息都只能存储在Queue中，生产者（下图中的P）生产消息并最终投递到Queue中，消费者（下图中的C）可以从Queue中获取消息并消费。 多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。 Message acknowledgment在实际应用中，可能会发生消费者收到Queue中的消息，但没有处理完成就宕机（或出现其他意外）的情况，这种情况下就可能会导致消息丢失。为了避免这种情况发生，我们可以要求消费者在消费完消息后发送一个回执给RabbitMQ，RabbitMQ收到消息回执（Message acknowledgment）后才将该消息从Queue中移除；如果RabbitMQ没有收到回执并检测到消费者的RabbitMQ连接断开，则RabbitMQ会将该消息发送给其他消费者（如果存在多个消费者）进行处理。这里不存在timeout概念，一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的RabbitMQ连接断开。这里会产生另外一个问题，如果我们的开发人员在处理完业务逻辑后，忘记发送回执给RabbitMQ，这将会导致严重的bug——Queue中堆积的消息会越来越多；消费者重启后会重复消费这些消息并重复执行业务逻辑… Message durability如果我们希望即使在RabbitMQ服务重启的情况下，也不会丢失消息，我们可以将Queue与Message都设置为可持久化的（durable），这样可以保证绝大部分情况下我们的RabbitMQ消息不会丢失。但依然解决不了小概率丢失事件的发生（比如RabbitMQ服务器已经接收到生产者的消息，但还没来得及持久化该消息时RabbitMQ服务器就断电了），如果我们需要对这种小概率事件也要管理起来，那么我们要用到事务。由于这里仅为RabbitMQ的简单介绍，所以这里将不讲解RabbitMQ相关的事务。 Prefetch count前面我们讲到如果有多个消费者同时订阅同一个Queue中的消息，Queue中的消息会被平摊给多个消费者。这时如果每个消息的处理时间不同，就有可能会导致某些消费者一直在忙，而另外一些消费者很快就处理完手头工作并一直空闲的情况。我们可以通过设置prefetchCount来限制Queue每次发送给每个消费者的消息数，比如我们设置prefetchCount=1，则Queue每次给每个消费者发送一条消息；消费者处理完这条消息后Queue会再给该消费者发送一条消息。 Exchange在上一节我们看到生产者将消息投递到Queue中，实际上这在RabbitMQ中这种事情永远都不会发生。实际的情况是，生产者将消息发送到Exchange（交换器，下图中的X），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。 Exchange是按照什么逻辑将消息路由到Queue的？这个将在Binding一节介绍。RabbitMQ中的Exchange有四种类型，不同的类型有着不同的路由策略，这将在Exchange Types一节介绍。 routing key生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255 bytes。 BindingRabbitMQ中通过Binding将Exchange与Queue关联起来，这样RabbitMQ就知道如何正确地将消息路由到指定的Queue了。 Binding key在绑定（Binding）Exchange与Queue的同时，一般会指定一个binding key；消费者将消息发送给Exchange时，一般会指定一个routing key；当binding key与routing key相匹配时，消息将会被路由到对应的Queue中。这个将在Exchange Types章节会列举实际的例子加以说明。在绑定多个Queue到同一个Exchange的时候，这些Binding允许使用相同的binding key。binding key 并不是在所有情况下都生效，它依赖于Exchange Type，比如fanout类型的Exchange就会无视binding key，而是将消息路由到所有绑定到该Exchange的Queue。 Exchange TypesRabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种（AMQP规范里还提到两种Exchange Type，分别为system与自定义，这里不予以描述），下面分别进行介绍。 fanoutfanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。 上图中，生产者（P）发送到Exchange（X）的所有消息都会路由到图中的两个Queue，并最终被两个消费者（C1与C2）消费。 directdirect类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中。 以上图的配置为例，我们以routingKey=”error”发送消息到Exchange，则消息会路由到Queue1（amqp.gen-S9b…，这是由RabbitMQ自动生成的Queue名称）和Queue2（amqp.gen-Agl…）；如果我们以routingKey=”info”或routingKey=”warning”来发送消息，则消息只会路由到Queue2。如果我们以其他routingKey发送消息，则消息不会路由到这两个Queue中。 topic前面讲到direct类型的Exchange路由规则是完全匹配binding key与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定： routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit” binding key与routing key一样也是句点号“. ”分隔的字符串 binding key中可以存在两种特殊字符“”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个） 以上图中的配置为例，routingKey=”quick.orange.rabbit”的消息会同时路由到Q1与Q2，routingKey=”lazy.orange.fox”的消息会路由到Q1，routingKey=”lazy.brown.fox”的消息会路由到Q2，routingKey=”lazy.pink.rabbit”的消息会路由到Q2（只会投递给Q2一次，虽然这个routingKey与Q2的两个bindingKey都匹配）；routingKey=”quick.brown.fox”、routingKey=”orange”、routingKey=”quick.orange.male.rabbit”的消息将会被丢弃，因为它们没有匹配任何bindingKey。 headersheaders类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。该类型的Exchange没有用到过（不过也应该很有用武之地），所以不做介绍。 RPCMQ本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到RabbitMQ后不会知道消费者（C）处理成功或者失败（甚至连有没有消费者来处理这条消息都不知道）。但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于RPC（Remote Procedure Call，远程过程调用）。在RabbitMQ中也支持RPC。 RabbitMQ中实现RPC的机制是： 客户端发送请求（消息）时，在消息的属性（MessageProperties，在AMQP协议中定义了14中properties，这些属性会随着消息一起发送）中设置两个值replyTo（一个Queue名称，用于告诉服务器处理完成后将通知我的消息发送到这个Queue中）和correlationId（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败） 服务器端收到消息并处理 服务器端处理完消息后，将生成一条应答消息到replyTo指定的Queue，同时带上correlationId属性 客户端之前已订阅replyTo指定的Queue，从中收到服务器的应答消息后，根据其中的correlationId属性分析哪条请求被执行了，根据执行结果进行后续业务处理","categories":[],"tags":[]},{"title":"UUID码","slug":"UUID码","date":"2018-03-13T16:00:00.000Z","updated":"2019-12-31T04:13:01.144Z","comments":true,"path":"2018/03/14/UUID码/","link":"","permalink":"http://yoursite.com/2018/03/14/UUID%E7%A0%81/","excerpt":"","text":"UUID码 UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。其目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。 组成UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和随机数。 UUID由以下几部分的组合： （1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。 （2）时钟序列。 （3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。 UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单地生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，可以从cflib 下载CreateGUID() UDF进行转换。 python有一个模块叫做uuid，导入它就可以使用它的四个方法了。注意这四个方法依次是uuid1(),uuid3(),uuid4(),uuid5(),然而并没有uuid2() 基于时间戳 使用主机ID, 序列号, 和当前时间来生成UUID, 可保证全球范围的唯一性. 但由于使用该方法生成的UUID中包含有主机的网络地址, 因此可能危及隐私. 123 uuid.uuid1(node=None, clock_seq=None)In [1]: uuid.uuid1() Out[2]: UUID('bd6a74ec-f8ae-11e9-bad5-f8a2d6d4d3ac') 打断一下… 在uuid3() 和 uuid5() 两个方法里涉及到了一个 namespace 的参数，python提供了四种生成namespace的方法。 uuid.NAMESPACE_DNS : 指定此命名空间时，名称字符串是完全限定的域名 uuid.NAMESPACE_URL: 指定此命名空间时，名称字符串是URL uuid.NAMESPACE_OID: 指定此命名空间时，名称字符串是ISO OID uuid.namespace_x500: the name string is an X.500 DN in DER or a text output format (咱也不懂，也不敢问) 基于名字的MD5散列值 通过计算命名空间和名字的MD5散列值来生成UUID, 可以保证同一命名空间中不同名字的唯一性和不同命名空间的唯一性, 但同一命名空间的同一名字生成的UUID相同 123uuid.uuid3(namespace, name)In [9]: uuid.uuid3(uuid.NAMESPACE_URL,'python.org')Out[9]: UUID('22fe6191-c161-3d86-a432-a81f343eda08') 基于随机数 通过随机数来生成UUID. 使用的是伪随机数有一定的重复概率 12In [10]: uuid.uuid4()Out[10]: UUID('0faccaf9-d093-41c9-ac18-1cee7dcf4c72') 基于名字的SHA-1散列值 算法与 uuid3() 相同 12In [11]: uuid.uuid5(uuid.NAMESPACE_URL,'python.org')Out[11]: UUID('7af94e2b-4dd9-50f0-9c9a-8a48519bdef0')","categories":[],"tags":[]},{"title":"git服务搭建","slug":"git服务搭建","date":"2017-08-20T16:00:00.000Z","updated":"2019-12-31T04:21:39.415Z","comments":true,"path":"2017/08/21/git服务搭建/","link":"","permalink":"http://yoursite.com/2017/08/21/git%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/","excerpt":"","text":"创建用户账号添加用户： useradd test_user 设置密码： passwd test_user 登录： ssh test_user@62.234.92.111 命令格式： ssh 用户名@ip地址 使用公钥私钥登录配置sshd服务参数1234vi /etc/ssh/sshd_configRSAAuthentication yes # 启用RSA 非对称加密算法PubkeyAuthentication yes # 公钥认证PasswordAuthentication yes #允许密码认证 修改配置后需要重启服务： systemctl restart sshd.service 创建ssh权限目录和文件生成公钥私钥： ssh-keygen 切换用户 su - test_user 创建文件夹： mkdir .ssh 设置.ssh目录权限 chmod 700 .ssh 创建文件： touch .ssh/authorized_keys 设置authorized_keys权限 chmod 600 .ssh/authorized_keys 使用证书登录 ssh test_user@62.234.92.111 -i 证书路径 搭建git服务创建git用户 useradd git 设置git用户ssh权限目录和文件 创建一个裸版本库 12su - git # 登录git用户git init --bare project.git # 创建一个裸仓库 创建一个文件并提交12345touch readme.txt # 创建readme.txt 文件git add readme.txt # 添加到暂存区中 git commit -m &quot;添加readme文件&quot; # 提交到本地版本库里git push origin # 推送到远程仓库git pull origin # 拉取文件 git 常用命令12git statusgit","categories":[],"tags":[]},{"title":"git bush 中的一些项目操作","slug":"git bush 中的一些项目操作","date":"2017-05-28T16:00:00.000Z","updated":"2019-12-31T04:11:25.347Z","comments":true,"path":"2017/05/29/git bush 中的一些项目操作/","link":"","permalink":"http://yoursite.com/2017/05/29/git%20bush%20%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A1%B9%E7%9B%AE%E6%93%8D%E4%BD%9C/","excerpt":"","text":"git bush 中的一些项目操作123456789101112131415// 创建功能分支git flow feature start 分支名称// 推送远程仓库留档git flow feature publish 分支名称// 完成并保存本地分支git flow feature finish -k 分支名称// 合并功能分支到devgit checkout develop // 切换分支git pull origin develop // 更新远端仓库至本地git merge feature/分支名 // 合并至dev分支git push origin develop // 推送远端仓库// other optgit push origin --delete 分支名称 // 删除远端仓库分支git branch -d/-D(强制删除) 分支名称 // 删除本地仓库分支","categories":[],"tags":[]},{"title":"生成随机字符串","slug":"生成随机字符串","date":"2016-11-04T16:00:00.000Z","updated":"2019-12-31T04:12:10.973Z","comments":true,"path":"2016/11/05/生成随机字符串/","link":"","permalink":"http://yoursite.com/2016/11/05/%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"生成随机字符串1234567891011121314151617181920212223242526272829303132333435import osimport base64import randomimport timeimport hashlib# 方法一tmp = os.urandom(44)secret_key = base64.b64encode(tmp)print(secret_key)# 方法二def get_random_secret_key(length=12, allowed_chars=None, secret_key=None): \"\"\" 生成随机字符串 :param length: 随机字符串长度 :param allowed_chars: 随机字符串字符取值范围 :param secret_key: 生成随机字符串的随机字符串 :return: \"\"\" if secret_key is None: secret_key = \"n&amp;^-9#k*-6pwzsjt-qsc@s3$l46k(7e%f80e7gx^f#vouf3yvz\" if allowed_chars is None: allowed_chars = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*(-_=+)' random.seed( hashlib.sha256( (\"%s%s%s\" % ( random.getstate(), time.time(), secret_key)).encode('utf-8') ).digest()) ret = ''.join(random.choice(allowed_chars) for i in range(length)) return ret","categories":[],"tags":[]},{"title":"flask在服务器上运行","slug":"flask在服务器上运行","date":"2016-10-09T16:00:00.000Z","updated":"2019-12-31T04:18:30.172Z","comments":true,"path":"2016/10/10/flask在服务器上运行/","link":"","permalink":"http://yoursite.com/2016/10/10/flask%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8C/","excerpt":"","text":"1.上传项目将项目文件使用Xftp上传至某目录下 2.修改nginx配置文件在/etc/nginx/conf.d/文件夹下找到其配置文件添加nginx 需要监听的端口信息末尾添加类似代码 12345678server &#123; listen 8001; #主机公网IP server_name instagram.zhyh2010.com; location /&#123; proxy_pass http://127.0.0.1:8000; &#125;&#125; 实际上， 我们将外部通过 8001 端口发送过来的请求， 代理给了 127.0.0.1:8000 也就是我们的 flask 项目 3.配置文件修改重装载 1nginx -s reload 附Nginx操作代码： 1234567891011121314#重启服务：service nginx restart#快速停止或关闭Nginx：nginx -s stop 正常停止或关闭Nginx：nginx -s quit 配置文件修改重装载命令：nginx -s reload查看端口运行状态：netstat -ntlp 运行程序进入项目目录 1234#确保已装flaskpip install flask#运行程序python app.py ————————————————","categories":[],"tags":[]},{"title":"python开发规范","slug":"python开发规范","date":"2016-09-25T02:44:26.000Z","updated":"2019-11-28T06:33:11.818Z","comments":true,"path":"2016/09/25/python开发规范/","link":"","permalink":"http://yoursite.com/2016/09/25/python%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","excerpt":"","text":"分号Tip 不要在行尾加分号, 也不要用分号将两条命令放在同一行. 行长度Tip 每行不超过80个字符 例外: 长的导入模块语句 注释里的URL 不要使用反斜杠连接行. Python会将 圆括号, 中括号和花括号中的行隐式的连接起来 , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号. 12345Yes: foo_bar(self, width, height, color='black', design=None, x='foo', emphasis=None, highlight=0) if (width == 0 and height == 0 and color == 'red' and emphasis == 'strong'): 如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接: 12x = ('This will build a very long long ' 'long long long long long long string') 在注释中，如果必要，将长的URL放在一行上。 12345Yes: # See details at # http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.htmlNo: # See details at # http://www.example.com/us/developer/documentation/api/content/\\ # v2.0/csv_file_name_extension_full_specification.html 注意上面例子中的元素缩进; 你可以在本文的 缩进 部分找到解释. 括号Tip 宁缺毋滥的使用括号 除非是用于实现行连接, 否则不要在返回语句或条件语句中使用括号. 不过在元组两边使用括号是可以的. 123456789101112131415Yes: if foo: bar() while x: x = bar() if x and y: bar() if not x: bar() return foo for (x, y) in dict.items(): ...No: if (x): bar() if not(x): bar() return (foo) 缩进Tip 用4个空格来缩进代码 绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素(见 行长度 部分的示例), 或者使用4空格的悬挂式缩进(这时第一行不应该有参数): 12345678910111213141516171819202122232425262728293031323334353637Yes: # Aligned with opening delimiter foo = long_function_name(var_one, var_two, var_three, var_four) # Aligned with opening delimiter in a dictionary foo = &#123; long_dictionary_key: value1 + value2, ... &#125; # 4-space hanging indent; nothing on first line foo = long_function_name( var_one, var_two, var_three, var_four) # 4-space hanging indent in a dictionary foo = &#123; long_dictionary_key: long_dictionary_value, ... &#125;No: # Stuff on first line forbidden foo = long_function_name(var_one, var_two, var_three, var_four) # 2-space hanging indent forbidden foo = long_function_name( var_one, var_two, var_three, var_four) # No hanging indent in a dictionary foo = &#123; long_dictionary_key: long_dictionary_value, ... &#125; 空行Tip 顶级定义之间空两行, 方法定义之间空一行 顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行. 空格Tip 按照标准的排版规范来使用标点两边的空格 括号内不要有空格. 12Yes: spam(ham[1], &#123;eggs: 2&#125;, [])No: spam( ham[ 1 ], &#123; eggs: 2 &#125;, [ ] ) 不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾). 123456Yes: if x == 4: print x, y x, y = y, xNo: if x == 4 : print x , y x , y = y , x 参数列表, 索引或切片的左括号前不应加空格. 1234Yes: spam(1)no: spam (1)Yes: dict['key'] = list[index]No: dict ['key'] = list [index] 在二元操作符两边都加上一个空格, 比如赋值(=), 比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not), 布尔(and, or, not). 至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致. 12Yes: x == 1No: x&lt;1 当’=’用于指示关键字参数或默认参数值时, 不要在其两侧使用空格. 12Yes: def complex(real, imag=0.0): return magic(r=real, i=imag)No: def complex(real, imag = 0.0): return magic(r = real, i = imag) 不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等): 12345678910111213141516Yes: foo = 1000 # comment long_name = 2 # comment that should not be aligned dictionary = &#123; \"foo\": 1, \"long_name\": 2, &#125;No: foo = 1000 # comment long_name = 2 # comment that should not be aligned dictionary = &#123; \"foo\" : 1, \"long_name\": 2, &#125; 注释Tip 确保对模块, 函数, 方法和行内注释使用正确的风格 文档字符串 Python有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的doc成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号”“”( PEP-257 ). 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范. 模块 每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板. 函数和方法 下文所指的函数,包括函数, 方法, 以及生成器. 一个函数必须要有文档字符串, 除非它满足以下条件: 外部不可见 非常短小 简单明了 文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述”怎么做”, 除非是一些复杂的算法. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有意义. 关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述. 每节应该以一个标题行开始. 标题行以冒号结尾. 除标题行外, 节的其他内容应被缩进2个空格. Args: 列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受foo(可变长度参数列表)或者*bar (任意关键字参数), 应该详细列出foo和*bar. Returns: (或者 Yields: 用于生成器) 描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略. Raises: 列出与接口有关的所有异常. 123456789101112131415161718192021222324252627282930def fetch_bigtable_rows(big_table, keys, other_silly_variable=None): \"\"\"Fetches rows from a Bigtable. Retrieves rows pertaining to the given keys from the Table instance represented by big_table. Silly things may happen if other_silly_variable is not None. Args: big_table: An open Bigtable Table instance. keys: A sequence of strings representing the key of each table row to fetch. other_silly_variable: Another optional variable, that has a much longer name than the other args, and which does nothing. Returns: A dict mapping keys to the corresponding table row data fetched. Each row is represented as a tuple of strings. For example: &#123;'Serak': ('Rigel VII', 'Preparer'), 'Zim': ('Irk', 'Invader'), 'Lrrr': ('Omicron Persei 8', 'Emperor')&#125; If a key from the keys argument is missing from the dictionary, then that row was not found in the table. Raises: IOError: An error occurred accessing the bigtable.Table object. \"\"\" pass 类 类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式. 123456789101112131415161718class SampleClass(object): \"\"\"Summary of class here. Longer class information.... Longer class information.... Attributes: likes_spam: A boolean indicating if we like SPAM or not. eggs: An integer count of the eggs we have laid. \"\"\" def __init__(self, likes_spam=False): \"\"\"Inits SampleClass with blah.\"\"\" self.likes_spam = likes_spam self.eggs = 0 def public_method(self): \"\"\"Performs operation blah.\"\"\" 块注释和行注释 最需要写注释的是代码中那些技巧性的部分. 如果你在下次 代码审查 的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释. 123456# We use a weighted dictionary search to find out where i is in# the array. We extrapolate position based on the largest num# in the array and the array size and then do binary search to# get the exact number.if i &amp; (i-1) == 0: # True if i is 0 or a power of 2. 为了提高可读性, 注释应该至少离开代码2个空格. 另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么. 12# BAD COMMENT: Now go through the b array and make sure whenever i occurs# the next element is i+1 类Tip 如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样. 1234567891011121314151617181920Yes: class SampleClass(object): pass class OuterClass(object): class InnerClass(object): pass class ChildClass(ParentClass): \"\"\"Explicitly inherits from another class already.\"\"\"No: class SampleClass: pass class OuterClass: class InnerClass: pass 继承自 object 是为了使属性(properties)正常工作, 并且这样可以保护你的代码, 使其不受 PEP-3000 的一个特殊的潜在不兼容性影响. 这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 包括 __new__, __init__, __delattr__, __getattribute__, __setattr__, __hash__, __repr__, and __str__ . 导入格式Tip 每个导入应该独占一行 12345#对的 import osimport sys#错的import os, sys 导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组: 标准库导入 第三方库导入 应用程序指定导入 每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写. 12345import foofrom foo import barfrom foo.bar import bazfrom foo.bar import Quuxfrom Foob import ar 语句Tip 通常每个语句应该独占一行 不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行. 如果是if语句, 只有在没有else时才能这样做. 特别地, 绝不要对 try/except 这样做, 因为try和except不能放在同一行. 1234567891011121314#对的 if foo: bar(foo)#错的 if foo: bar(foo) else: baz(foo) try: bar(foo) except ValueError: baz(foo) try: bar(foo) except ValueError: baz(foo) 命名module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name. 应该避免的名称 单字符名称, 除了计数器和迭代器. 包/模块名中的连字符(-) 双下划线开头并结尾的名称(Python保留, 例如init) 命名约定 所谓”内部(Internal)”表示仅模块内可用, 或者, 在类内是保护或私有的. 用单下划线(_)开头表示模块变量或函数是protected的(使用from module import *时不会包含). 用双下划线(__)开头的实例变量或方法表示类内私有. 将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块. 对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰. Python之父Guido推荐的规范 Type Public Internal Modules lower_with_under _lower_with_under Packages lower_with_under Classes CapWords _CapWords Exceptions CapWords Functions lower_with_under() _lower_with_under() Global/Class Constants CAPS_WITH_UNDER _CAPS_WITH_UNDER Global/Class Variables lower_with_under _lower_with_under Instance Variables lower_with_under _lower_with_under (protected) or __lower_with_under (private) Method Names lower_with_under() _lower_with_under() (protected) or __lower_with_under() (private) Function/Method Parameters lower_with_under Local Variables lower_with_under","categories":[],"tags":[]}]}