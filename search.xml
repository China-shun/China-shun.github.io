<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>flask-socketio</title>
    <url>/2019/11/28/flask-socketio/</url>
    <content><![CDATA[<!-- vim-markdown-toc GFM -->

<ul>
<li><a href="#flask-socketio">flask-socketio</a><ul>
<li><a href="#installation安装">Installation(安装)</a></li>
<li><a href="#requirements依赖">Requirements(依赖)</a></li>
<li><a href="#initialization初始化">Initialization(初始化)</a></li>
<li><a href="#receiving-messages接收消息-">Receiving Messages(接收消息) ==</a></li>
<li><a href="#sending-messages发送消息">Sending Messages(发送消息)</a></li>
<li><a href="#broadcasting广播">Broadcasting(广播)</a></li>
<li><a href="#rooms房间">Rooms(房间)</a></li>
<li><a href="#connection-events连接事件">Connection Events(连接事件)</a></li>
<li><a href="#class-based-namespaces基于类的命名空间">Class-Based Namespaces(基于类的命名空间)</a></li>
<li><a href="#error-handling">Error Handling</a></li>
<li><a href="#access-to-flasks-context-globals访问flask的全局上下文">Access to Flask’s Context Globals(访问Flask的全局上下文)</a></li>
<li><a href="#authentication验证">Authentication(验证)</a></li>
<li><a href="#使用带有flask-socketio的flask-login">使用带有Flask-SocketIO的Flask-Login</a></li>
<li><a href="#deployment部署">Deployment(部署)</a><ul>
<li><a href="#using-nginx-as-a-websocket-reverse-proxy使用nginx作为websocket反向代理">Using nginx as a WebSocket Reverse Proxy(使用nginx作为WebSocket反向代理)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#todo">TODO</a><ul>
<li><a href="#using-multiple-workers使用多个工作者">Using Multiple Workers(使用多个工作者)</a></li>
<li><a href="#emitting-from-an-external-process">Emitting from an External Process</a></li>
</ul>
</li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- vim-markdown-toc -->


<h1 id="flask-socketio"><a href="#flask-socketio" class="headerlink" title="flask-socketio"></a>flask-socketio</h1><p><em>Flask-SocketIO</em> 给Flask应用提供了客户端和服务端低延时双向通信。客户端这边应用程序可以使用<br>Javascript，C++，Java，Swift的官方SocketIO库,或者兼容客户端向服务端建立一个持久链接的编程语言<br>中任意一个官方[[<a href="http://socket.io/|SocketIO]]库。" target="_blank" rel="noopener">http://socket.io/|SocketIO]]库。</a></p>
<h2 id="Installation-安装"><a href="#Installation-安装" class="headerlink" title="Installation(安装)"></a>Installation(安装)</h2><p><code>pip install flask-socketio</code></p>
<h2 id="Requirements-依赖"><a href="#Requirements-依赖" class="headerlink" title="Requirements(依赖)"></a>Requirements(依赖)</h2><p>Flask-SocketIO兼容python2.7和python3.3+。Flask-SocketIO包的异步服务依赖于以下三种选择:</p>
<ul>
<li><a href="http://eventlet.net/" target="_blank" rel="noopener">eventlet</a>是最好的选择,支持长轮询和WebSocket传输</li>
<li><a href="http://www.gevent.org/" target="_blank" rel="noopener">gevent</a>支持不同的配置。长轮询在gevent包里被完全支持,但是不像eventlet，gevent自己并不支持WebSocket。为了支持WebSocket当前有两个选择。安装<a href="https://pypi.python.org/pypi/gevent-websocket/" target="_blank" rel="noopener">gevent-websocket</a>包和使用<a href="https://uwsgi-docs.readthedocs.io/en/latest/" target="_blank" rel="noopener">uWSGI</a>web服务，uWSGI提供WebSocket功能。gevent也是一个不错的选择，但是略低于eventlet。</li>
<li>基于Werkzeug的Flask开发服务也可以用，但是给出警告，它的性能低于前两个选择，所以它应该被用于开发中。这个选项只支持长轮训传输。</li>
</ul>
<p>采用哪个异步框架取决于本机安装了什么。优先使用eventlet，gevent次之。对于gevent中支持WebScket， uWSGI优先，gevent-websocket次之。如果既没有eventlet也没有gevent安装，那么使用Flask开发服务。</p>
<p>如果使用多进程，消息队列服务将被用于协调操作，例如广播。支持的队列有<a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>,<a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>,和任意支持<a href="http://kombu.readthedocs.org/en/latest/" target="_blank" rel="noopener">Kombu</a>包的消息队列。</p>
<p>客户端这边，官方的Socket.IO Javascript客户端库可以用来和服务端建立连接。这里也有些用Swift，Java，C++写的官方客户端。非官方客户端可能也能工作，只要实现了<a href="https://github.com/socketio/socket.io-protocol" target="_blank" rel="noopener">Socket.IO协议</a></p>
<h2 id="Initialization-初始化"><a href="#Initialization-初始化" class="headerlink" title="Initialization(初始化)"></a>Initialization(初始化)</h2><p>下面代码例子展示了如何在Flask应用中添加Flask-SocketIO：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"><span class="keyword">from</span> flask_socketio imoprt SocketIO</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SECRET_KEY'</span>] = <span class="string">'secret!'</span></span><br><span class="line">socketio = SocketIO(app)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    socketio.run(app)</span><br></pre></td></tr></table></figure>
<p>init_app()风格的初始化也是被支持的。注意这种方式中web服务被启动了。socketio.run()方法封装了web服务的启动并且替代了app.run()来启动Flask开发服务。当应用在debug模式Werkzeug开发服务将被使用并且是在socketio.run()来配置属性。在生产模式如果eventlet有效，eventlet web服务将被使用，否则使用gevent的。如果eventlet和gevent都没安装，将使用Werkzeug开发web服务。</p>
<p>Flask 0.11引入的”flask运行命令”可以用来启动基于Werkzeug的Flask-SocketIO开发服务，但是这种方式启动由于缺少对WebSocket支持而被不推荐。这个包（flask-socket）的之前版本包含了“flask运行命令”，允许使用eventlet和gevent的WebSocket生产服务。但是这个功能已经在上面展示的socketio.run(app)中停止了。</p>
<p>这个应用只能服务于客户端页面。客户端加载了Socket.IO库和建立连接。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> socket = io.connect(<span class="string">'http://'</span> + <span class="built_in">document</span>.domain + <span class="string">':'</span> + location.port);</span><br><span class="line">    socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        socket.emit(<span class="string">'my event'</span>, &#123;<span class="attr">data</span>: <span class="string">'I\'m connected!'</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Receiving-Messages-接收消息"><a href="#Receiving-Messages-接收消息" class="headerlink" title="Receiving Messages(接收消息) =="></a>Receiving Messages(接收消息) ==</h2><p>当使用SocketIO，消息被事件的两端接收。客户端这边使用Javascript回调。使用Flask-SocketIO,服务端需要注册这些事件的处理，类似路由通过视图函数处理。</p>
<p>下面例子给一个无名事件创建服务端这边的事件处理函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    print(<span class="string">'received message: '</span> + message)</span><br></pre></td></tr></table></figure>
<p>上线例子使用字符消息。另一个无名事件使用JSON数据:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('json')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_json</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'received json:'</span> + str(json))</span><br></pre></td></tr></table></figure>
<p>最灵活的事件类型是自定义事件名称。这些事件的消息数据可以是string,bytes，int或者JSON:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'received json:'</span> _ str(json))</span><br></pre></td></tr></table></figure>
<p>自定义名称事件也支持多参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(args1, args2, args3)</span>:</span></span><br><span class="line">    print(<span class="string">'received args:'</span> + args1 + args2 + args3)</span><br></pre></td></tr></table></figure>
<p>命名事件是非常灵活的，因为它们不需要包括额外元数据来描述消息类型。<br>Flask-SocketIO也支持SocketIO命名空间，命名空间允许客户端通过多个不同独立连接在同一个物理socket上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event', namespace='/test')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_namespace_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'receviced json:'</span> + str(json))</span><br></pre></td></tr></table></figure>
<p>当命名空间没有指定，默认全局命名空间’/‘将被使用。<br>对于某些时候装饰器语法并不方便，on_event方法可以使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function_handler</span><span class="params">(darta)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">socketio.on_event(<span class="string">'my event'</span>, my_function_handler, namespace=<span class="string">'/test'</span>)</span><br></pre></td></tr></table></figure>
<p>客户端要求服务端回复一个确认收到客户端发来消息的应答,处理函数返回的任何值都将传给客户端作为回调函数的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'received json:'</span> + str(json))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'one'</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子，客户端回调函数携带两个参数进行调用，’one’和2。如果处理函数没有任何返回值，客户端回调函数将不携带任何参数进行调用。</p>
<h2 id="Sending-Messages-发送消息"><a href="#Sending-Messages-发送消息" class="headerlink" title="Sending Messages(发送消息)"></a>Sending Messages(发送消息)</h2><p>之前章节里定义的SocketIO事件处理函数可以通过send()和emit()函数发送回复消息给连接的客户端。</p>
<p>下面例子将收到的消息返回给发送过来的客户端：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> send, emit</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    send(message)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@socketio.on('json')    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_json</span><span class="params">(json)</span>:</span></span><br><span class="line">    send(json, json=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@socketio.on('my event')    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_envent</span><span class="params">(json)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, json)</span><br></pre></td></tr></table></figure>
<p>注意send()和emit()如何被用来分别给无名和命名事件发送消息的</p>
<p>当使用了命名空间，send()和emit()将默认使用发来消息的命名空间。可以通过指定可选参数namespace来给不同命名空间发送消息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    send(message, namespace=<span class="string">'/chat'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, json, namespace=<span class="string">'/chat'</span>)</span><br></pre></td></tr></table></figure>
<p>为了发送多个参数的事件，通过发送一个元组来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, (<span class="string">'foo'</span>, <span class="string">'bar'</span>, json), namespace=<span class="string">'/chat'</span>)</span><br></pre></td></tr></table></figure>
<p>使用回调时，Javascript客户端根据收到的消息来调用回调函数。客户端应用执行回调函数之后服务端调用相应的服务端回调。如果客户端的回调携带参数调用，这些参数也将作为服务端回调的参数</p>
<h2 id="Broadcasting-广播"><a href="#Broadcasting-广播" class="headerlink" title="Broadcasting(广播)"></a>Broadcasting(广播)</h2><p>另一个非常有用的SocketIO特性是消息广播。Flask-SocketIO通过send()和emit()中的可选参数broadcast=True来支持这个特性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(data)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, data, broadcast=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>当broadcast选项为True情况下发送消息，所有连接同个命名空间的客户端连接将收到这个消息，包括发送者。没有指定命名空间时，连接到全局命名空间的客户端将受到消息。注意广播消息不会调用回调函数。</p>
<p>上面所有例子都建立在服务端收到客户端的事件，但是有些应用服务端需要是消息的发起者。这对实现服务端发送通知给客户端很有用，比如在后台线程中。socketio.send()和socketio.emit()方法可以对所有连接的客户端广播：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_function</span><span class="params">()</span>:</span></span><br><span class="line">    socketio.emit(<span class="string">'some event'</span>, &#123;<span class="string">'data'</span>: <span class="number">42</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>注意在上下文感知上，socketio.send()和socketio.emit()是不一样的函数。也要注意上面没有客户端上下文的用法,所以broadcast=True是假定的并且不需要特指。</p>
<h2 id="Rooms-房间"><a href="#Rooms-房间" class="headerlink" title="Rooms(房间)"></a>Rooms(房间)</h2><p>对于很多应用对用户分组成子集并在子集中互相通信是必要的。很好的一个例子是多房间的聊天室，这里用户收到来自一个或多个他们进入的房间，但是不会收到另外房间的消息。Flask-SocketIO通过join_room()和leave_room()来支持房间概念:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> join_room, leave_room</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('join')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_join</span><span class="params">(data)</span>:</span></span><br><span class="line">    username = data[<span class="string">'username'</span>]</span><br><span class="line">    room = data[<span class="string">'room'</span>]</span><br><span class="line">    join_room(room)</span><br><span class="line">    send(username + <span class="string">' has entered the room.'</span>, room=room)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('leave')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_leave</span><span class="params">(data)</span>:</span></span><br><span class="line">    username = data[<span class="string">'username'</span>]</span><br><span class="line">    room = data[<span class="string">'room'</span>]</span><br><span class="line">    leave_room(room)</span><br><span class="line">    send(username + <span class="string">' has left the room.'</span>, room=room)</span><br></pre></td></tr></table></figure>
<p>send()和emit()函数接受可选参数room来控制消息发送给指定room的所有用户。</p>
<p>所有客户端在连接时赋值一个房间，名字使用连接的session ID，通过request.sid获得。客户端可以加入任何房间，房间可以起任何名称。当客户端断开连接，它将从进入过的房间移除。上下文无关socketio.send()和socketio.emit()函数也同样接受room参数来对一个房间进行广播</p>
<p>由于所有客户端分配到个人房间，给单个客户端发消息，客户端的session ID可以用来做room参数</p>
<h2 id="Connection-Events-连接事件"><a href="#Connection-Events-连接事件" class="headerlink" title="Connection Events(连接事件)"></a>Connection Events(连接事件)</h2><p>Flask-SocketIO也派遣连接和断开连接事件。下面例子展示如何为它们注册处理函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('connect', namespace='/chat')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_connect</span><span class="params">()</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, &#123;<span class="string">'data'</span>: <span class="string">'Connected'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('disconnect', namespace='/chat')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_disconnect</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Client disconnected'</span>)</span><br></pre></td></tr></table></figure>
<p>connection事件处理函数可以返回False来拒绝连接，这里便于客户端在这里权限校验<br>注意connection和disconnection事件在每个命名空间独立发送</p>
<h2 id="Class-Based-Namespaces-基于类的命名空间"><a href="#Class-Based-Namespaces-基于类的命名空间" class="headerlink" title="Class-Based Namespaces(基于类的命名空间)"></a>Class-Based Namespaces(基于类的命名空间)</h2><p>一种是上面描述的基于装饰器的事件处理，另一种方式是创建类方法作为事件处理。flask_socketio.Namespace作为基类来创建一个基于类的命名空间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> Namespace, emit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomNamespace</span><span class="params">(Namespace)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_disconnect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_my_event</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        emit(<span class="string">'my_response'</span>, data)</span><br><span class="line">socketio.on_namespace(MyCustomNamespace(<span class="string">'/test'</span>))</span><br></pre></td></tr></table></figure>
<p>当基于类的命名空间被启用，任何被服务端收到的事件将派遣到方法名是以事件名加on_为前缀的方法中。举个例子，事件my_event将被方法名为on_my_event处理。如果收到一个事件在类命名空间中没有对应的方法，那么事件将被忽略。所有使用命名空间类的事件名必须使用方法名合法的字符。</p>
<blockquote>
<p>[原文]As a convenience to methods defined in a class-based namespace, the namespace instance includes versions of several of the methods in the flask_socketio.SocketIO class that default to the proper namespace when the namespace argument is not given.</p>
</blockquote>
<p>如果一个事件即有命名空间类的处理方法也有装饰器处理函数，那么只有装饰器处理函数被调用。</p>
<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><p>Flask-SocketIO也可以处理异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on_error()        # Handles the default namespace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_handler</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on_error('/chat') # handles the '/chat' namespace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_handler_chat</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on_error_default  # handles all namespaces without an explicit error handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_error_handler</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>错误处理函数将异常对象作为一个参数</p>
<p>当前请求的消息和数据参数可以通过request.event变量来检查，这有利于外部活动处理函数的错误日志和调试:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on("my error event")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_my_event</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> RuntimeError()</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on_error_default</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_error_handler</span><span class="params">(e)</span>:</span></span><br><span class="line">    print(request.event[<span class="string">"message"</span>]) <span class="comment"># "my error event"</span></span><br><span class="line">    print(request.event[<span class="string">"args"</span>])    <span class="comment"># (data,)</span></span><br></pre></td></tr></table></figure>

<h2 id="Access-to-Flask’s-Context-Globals-访问Flask的全局上下文"><a href="#Access-to-Flask’s-Context-Globals-访问Flask的全局上下文" class="headerlink" title="Access to Flask’s Context Globals(访问Flask的全局上下文)"></a>Access to Flask’s Context Globals(访问Flask的全局上下文)</h2><p>SocketIO事件处理函数不同于路由处理函数，这里介绍SocketIO处理函数中在哪些能做哪些不能做中容易混淆的东西。最主要的不同是所有SocketIO事件发生在单个长期运行的上下文请求之中。</p>
<p>尽管不同，但Flask-SocketIO尝试使SocketIO事件处理和常规HTTP请求的环境相似。下面描述了哪些还能正常工作，哪些不能了：</p>
<ul>
<li>在事件处理函数之前,应用上下文被压入（保存在数据结构中）使得current_app和g可以在处理函数中可用。</li>
<li>在调用处理函数之前请求上下文也被压入，同样使得request和session可用。但是注意WebSocket事件没有与之相关联的请求，所以对于在存活的连接中所有被派遣的事件请求上下文是在开始连接的时候被压入。</li>
<li>请求上下文(全局变量request)被连接产生的唯一session ID设置的sid变量所增强(request全局变量里增加了sid,http请求中是没有sid的)。这个值被用来初始化客户端加入的房间(room)。</li>
<li>请求上下文被含有命名空间和事件参数的namespace和event成员所增强(request中增加了namespace和event变量)。event成员是一个含有message和args的字典。</li>
<li>全局上下文变量<code>session</code>行为和常规的请求不一样。在SocketIO建立使处理函数在连接上下文中被调用的时候用户session被拷贝了一份。如果SocketIO处理函数修改了session，被修改的session变量将会被后续SocketIO处理函数有效，但是常规HTTP路由的处理函数看不到修改的变化。实际上，当SocketIO处理函数修改session，session的副本将被创建用于这些处理函数。这种限制的技术原因是，为了保存用户会话，需要将cookie发送到客户机，这需要HTTP请求和响应，而SocketIO连接中不存在这样的请求和响应。当使用诸如Flask-Session或Flask-KVSession扩展提供的服务器端会话时，只要会话没有在SocketIO处理程序中修改，SocketIO处理程序就可以看到HTTP路由处理程序中对会话所做的更改。</li>
<li>before_request和after_request钩子在SocketIO事件处理中无效。</li>
<li>SocketIO处理函数可以使用自定义的装饰器，但是许多Flask装饰器不能用在SocketIO处理函数上，在SocketIO连接中没有响应对象这个概念。</li>
</ul>
<h2 id="Authentication-验证"><a href="#Authentication-验证" class="headerlink" title="Authentication(验证)"></a>Authentication(验证)</h2><p>应用的共同需要就是验证他们用户的身份。自从SocketIO没有使用HTTP请求和应答，传统的基于网页表单和HTTP请求的机制不能用于SocketIO连接。如果需要的话，应用可以实施自定义的登陆表单，当用户按下提交按钮时，它利用一个SocketIO消息将证书发送到服务器。</p>
<p>然而，在大多数情况下，在SocketIO连接建立之前使用传统的身份验证方式会更加方便，用户的身份信息可以被记录下来作为用户会话或者cookie，之后在SocketIO连接建立起来的时候，这些信息也可以被SocketIO活动处理器得到。</p>
<h2 id="使用带有Flask-SocketIO的Flask-Login"><a href="#使用带有Flask-SocketIO的Flask-Login" class="headerlink" title="使用带有Flask-SocketIO的Flask-Login"></a>使用带有Flask-SocketIO的Flask-Login</h2><p>Flask-SocketIO可以访问被<a href="https://flask-login.readthedocs.org/en/latest/" target="_blank" rel="noopener">Flask-Login</a>维护的登录信息。Flask-Login鉴定执行和<code>login_user()</code>函数调用来在用户session中记录用户后，任何SocketIO连接将可以访问<code>current_user</code>上下文比变量:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('connect')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect_handler</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> current_user.is_authenticated:</span><br><span class="line">        emit(<span class="string">'my response'</span>,</span><br><span class="line">             &#123;<span class="string">'message'</span>: <span class="string">'&#123;0&#125; has joined'</span>.format(current_user.name)&#125;,</span><br><span class="line">             broadcast=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># not allowed here</span></span><br></pre></td></tr></table></figure>

<p>注意<code>login_required</code>装饰器不能用于SocketIO事件处理器,但是自定义一个无权限断开连接的装饰器如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> flask_login <span class="keyword">import</span> current_user</span><br><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> disconnect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticated_only</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> current_user.is_authenticated:</span><br><span class="line">            disconnect()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="meta">@authenticated_only</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(data)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, &#123;<span class="string">'message'</span>: <span class="string">'&#123;0&#125; has joined'</span>.format(current_user.name)&#125;,</span><br><span class="line">         broadcast=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Deployment-部署"><a href="#Deployment-部署" class="headerlink" title="Deployment(部署)"></a>Deployment(部署)</h2><h3 id="Using-nginx-as-a-WebSocket-Reverse-Proxy-使用nginx作为WebSocket反向代理"><a href="#Using-nginx-as-a-WebSocket-Reverse-Proxy-使用nginx作为WebSocket反向代理" class="headerlink" title="Using nginx as a WebSocket Reverse Proxy(使用nginx作为WebSocket反向代理)"></a>Using nginx as a WebSocket Reverse Proxy(使用nginx作为WebSocket反向代理)</h3><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><h2 id="Using-Multiple-Workers-使用多个工作者"><a href="#Using-Multiple-Workers-使用多个工作者" class="headerlink" title="Using Multiple Workers(使用多个工作者)"></a>Using Multiple Workers(使用多个工作者)</h2><p>Flask-SocketIO从2.0版本开始在负载均衡器后面支持多个Worker(工作者).部署多个worker给Flask-SocketIO应用有能力在多个进程和主机上传播客户端连接,也因此可以支持更多的客户端并发。</p>
<p>使用多工作者模式需要两个依赖:</p>
<ul>
<li>负载均衡器必须被配置成从一个客户端来的所有HTTP请求发送到同一个worker处理。这个有时被称为”sticky sessions”。对于nginx，用ip_hash直接实现会话保持。Gunicorn不能被用于多个工作者，因为它的负载均衡算法不支持粘滞会话(sticky sessions)。</li>
<li>因为每一个server只拥有客户端连接的子集，所以例如Redis或者RabbitMQ这样的消息队列被用来协同一些操作，例如broadcasting(广播)和rooms。（译者注：这个应该好理解，多个worker部署在不同机器上，就有可能一个room的连接分布在不同机器上，如果要对房间内得人进行广播，那么必然要有个介质用来协调）。</li>
</ul>
<p>当在消息队列下工作就需要安装下面这些依赖:</p>
<ul>
<li>对于Redis，redis包必须安装(pip install redis).</li>
<li>对于RabbitMQ,kombu包必须安装(pip install kombu)</li>
<li>对于其它支持Kombu的消息队列，查看<a href="http://docs.celeryproject.org/projects/kombu/en/latest/introduction.html#transport-comparison" target="_blank" rel="noopener">Kombu documentation</a>来确定依赖什么</li>
<li>如果消息队列用到eventlet或者gevent,那么通常也需要python标准库的猴子补丁来让消息队列包工作</li>
</ul>
<p>为了让Flask-SocketIO服务器们跑起来，你必须首先确保有个消息队列跑起来。为了让Socket.IO服务器跑起来并且连接上消息队列，需要SocketIO构造器中增加一个message_queue参数：<br><code>socketio = SocketIO(app, message_queue=&#39;redis://&#39;)</code><br>message_queue参数值是你使用的消息队列URL连接。如果redis消息队列和服务跑在同一个主机上，可以使用’redis://‘URL。同样的，RabbitMQ队列使用’amqp://‘。Kombu包里的<a href="http://docs.celeryproject.org/projects/kombu/en/latest/userguide/connections.html?highlight=urls#urls" target="_blank" rel="noopener">文档</a>有描述它支持的队列URL格式。</p>
<h2 id="Emitting-from-an-External-Process"><a href="#Emitting-from-an-External-Process" class="headerlink" title="Emitting from an External Process"></a>Emitting from an External Process</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[[<a href="https://www.jianshu.com/p/d81397edd2b1]]" target="_blank" rel="noopener">https://www.jianshu.com/p/d81397edd2b1]]</a></p>
<p>[[<a href="https://flask-socketio.readthedocs.io/en/latest/]]" target="_blank" rel="noopener">https://flask-socketio.readthedocs.io/en/latest/]]</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用Hexo搭建自己的个人博客</title>
    <url>/2019/11/28/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="使用Hexo搭建自己的个人博客"><a href="#使用Hexo搭建自己的个人博客" class="headerlink" title="使用Hexo搭建自己的个人博客"></a>使用Hexo搭建自己的个人博客</h1><h2 id="从零开始搭建自己的静态博客"><a href="#从零开始搭建自己的静态博客" class="headerlink" title="从零开始搭建自己的静态博客"></a>从零开始搭建自己的静态博客</h2><h2 id="前提摘要"><a href="#前提摘要" class="headerlink" title="前提摘要"></a>前提摘要</h2><ol>
<li><p>可能不需要会写多少代码，会照葫芦画瓢对一些地方进行修改就好。</p>
</li>
<li><p>安装node.js npm 了解基础知识 个人觉得不了解好像也没什么问题，跟着装就好了。然后就了解了啊。</p>
</li>
<li><p>安装git 可以不知道git是什么 hexo配合github搭建博客会用到四个常用的命令 到时候掌握了这四个命令的作用就行了</p>
</li>
<li><p>有一个github账号 和其他账号的注册没有什么区别。用github作为服务器使用。</p>
<ul>
<li>注册地址：<a href="https://github.com/" target="_blank" rel="noopener" github地址"">github地址</a> </li>
</ul>
</li>
<li><p>会markdown就好，不会也没关系，现学也可以很快掌握。</p>
<ul>
<li>推荐markdown编辑器：<strong>typora</strong></li>
</ul>
</li>
</ol>
<h3 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h3><h4 id="1-1-安装node-js"><a href="#1-1-安装node-js" class="headerlink" title="1.1 安装node.js"></a>1.1 安装node.js</h4><p>下载地址如下：<a href="http://nodejs.cn/download/,' target=" _blank" rel="noopener" node.js下载地址'">node.js下载</a></p>
<p>下载自己所需要的版本，与安装普通软件没有任何区别。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-e801cad5c7ac29dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>安装node.js</p>
<p>检查一下是否安装成功</p>
<p>windows系统下快捷键win+r 输入cmd</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-fb00e279ad960100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/646/format/webp" alt="img"></p>
<p>打开终端</p>
<p>在终端输入 npm -v 显示版本号则为安装成功 版本号不用和我的一样</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-fd4c2c6f6d8482ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/852/format/webp" alt="img"></p>
<h4 id="1-2-安装git"><a href="#1-2-安装git" class="headerlink" title="1.2 安装git"></a>1.2 安装git</h4><p>下载地址及安装方法如下：<a href="https://git-scm.com/book/zh/v1/起步-安装-Git" target="_blank" rel="noopener">git安装</a> 安装地址和方法这里都有说了</p>
<p>git安装 过程 <a href="https://blog.csdn.net/qq_41782425/article/details/85183250" target="_blank" rel="noopener">https://blog.csdn.net/qq_41782425/article/details/85183250</a></p>
<p>若是安装成功 鼠标右键会出现这俩图表</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-9b846e0c0d9a36cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/266/format/webp" alt="img"></p>
<p>git安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这两个是必备的工具 一定要安装上才行</span><br></pre></td></tr></table></figure>

<h3 id="二、创建库"><a href="#二、创建库" class="headerlink" title="二、创建库"></a>二、创建库</h3><h4 id="2-1注册gitbub账号"><a href="#2-1注册gitbub账号" class="headerlink" title="2.1注册gitbub账号"></a>2.1注册gitbub账号</h4><p>本来不想从注册开始写的…然后想了想不能做一个标题党，所以真的从零开始哦。</p>
<p><strong>① 输入地址 点击注册</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-ad94a5bfcd8e08ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>github注册地址</p>
<p><strong>② 填写表单</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-660b8360cc189692.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>填写表单</p>
<p><strong>③ 继续 账号也就有了</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-8ff40dc12c6fe5ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>注册</p>
<h4 id="2-2-建立仓库"><a href="#2-2-建立仓库" class="headerlink" title="2.2 建立仓库"></a>2.2 建立仓库</h4><p><strong>① 新建项目</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-41d7fb68fec46d06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>新建项目</p>
<p><strong>② 上邮箱里验证一下</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-4f4802e0b3cf5cc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>验证</p>
<p><strong>③新建项目</strong></p>
<p>新建一个名为<code>你的用户名.github.io</code>的仓库，例如，你的github用户名为user，就新建一个名为<code>user.github.io</code>的仓库（强制要求哦），将来你的网站访问地址就为：<a href="http://user.github.io/" target="_blank" rel="noopener">http://user.github.io</a> 并且一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 </p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-93f26bbcd60d6d53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>项目命名</p>
<h4 id="2-4-配置SSH-KEY"><a href="#2-4-配置SSH-KEY" class="headerlink" title="2.4 配置SSH KEY"></a>2.4 配置SSH KEY</h4><p>我们到时候会把本地的代码提交到github上，这一步就是配置权限，解决本地和服务器的链接问题</p>
<p><strong>① 鼠标右键git bash here</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-08490aec3bed2a3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/267/format/webp" alt="img"></p>
<p>配置步骤1</p>
<p><strong>②打开git bash，就是一个linux命令窗口</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-4c4695a3381570a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>配置步骤2</p>
<p><strong>③创建SSH keys</strong></p>
<blockquote>
<p>在bash中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;shaoshanhuan@163.com&quot;</span><br></pre></td></tr></table></figure>

<p>然后无脑回车~</p>
</blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-89919b214d8343e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>配置成功</p>
<p><strong>④复制keys</strong></p>
<p>进入生成的ssh目录 : C:\users(中文是用户)\你电脑的用户名 .ssh 中, 使用记事本打开 id_rsa.pub 文件, 将该文件中的内容复制</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-51cf57860d9e1613.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>复制keys</p>
<p><strong>⑤复制id_rsa.pub里面的内容</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-9218ee6a3b2bd82b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1198/format/webp" alt="img"></p>
<p>id_rsa.pub</p>
<p><strong>⑥将复制的内容粘进github</strong></p>
<p>有些网页看不懂可以全页翻译</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-31872c2efd264fb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>配置1</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-157568471846db81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>配置2</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-9ddd7f5b656f9f9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>配置3</p>
<p>前面加 $ 的都是在 git bash 里面 运行的，不要把 黑窗口和 git bash 搞混淆了</p>
<p><strong>⑦测试是否成功</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p>
<blockquote>
<p>Hi ***! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
<p>看到这个信息说明SSH已配置成功！</p>
<p>此时你还需要配置：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"***"</span><span class="comment">// 你的github用户名，非昵称</span></span><br><span class="line">$ git config --global user.email  <span class="string">"xxx@qq.com"</span><span class="comment">// 填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure>

<h3 id="三、-初始化工程"><a href="#三、-初始化工程" class="headerlink" title="三、 初始化工程"></a>三、 初始化工程</h3><h4 id="3-1-全局安装hexo"><a href="#3-1-全局安装hexo" class="headerlink" title="3.1 全局安装hexo"></a>3.1 全局安装hexo</h4><p><strong>① 全局安装hexo</strong></p>
<p>打开终端输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p><strong>②创建hexo项目</strong></p>
<p>在你认为合适的地方新建文件夹，我将其放在d盘新建文件夹命名为hexo</p>
<p>终端切换到这个目录，执行以下命令为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">$ cd d:/hexo  <span class="comment">// 这个命令表示终端切换到d盘hexo目录下</span></span><br><span class="line">$ hexo <span class="keyword">init</span> blog  <span class="comment">// 初始化项目 项目名称为blog 这个过程可能会花费一些时间</span></span><br><span class="line">$ cd blog   <span class="comment">// 切换到blog目录下</span></span><br><span class="line">$ npm install   <span class="comment">// 这一步是安装所需的依赖</span></span><br><span class="line">$ hexo g # 或者hexo generate  <span class="comment">//生成静态文件</span></span><br><span class="line">$ hexo s # 或者hexo server    <span class="comment">//然后就可以在浏览器输入http://localhost:4000/ 就可以在本地查看初始化的项目了</span></span><br></pre></td></tr></table></figure>

<p>目录长这个样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<p>(1)  界面出不来的话可以试一试  <a href="http://localhost:4000//" target="_blank" rel="noopener">http://localhost:4000//</a></p>
<p>(2) 换一个 端口号  hexo server -p 5000</p>
<p>界面长这个样子：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-16c4570d693d9b37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>初始化界面</p>
<h4 id="3-2-下载并安装主题"><a href="#3-2-下载并安装主题" class="headerlink" title="3.2 下载并安装主题"></a>3.2 下载并安装主题</h4><p>一般应该很少人直接使用默认的主题吧，毕竟不是很好看。</p>
<p>我用的主题叫做<code>anisina</code>，因为作者的文档确实写的不太全，所以当时研究主题反而花了很多时间。</p>
<p>我就在这里详细介绍一下我用的主题咋配的吧，大家可以上网搜hexo主题 应该可以找到很多，挑自己喜欢的就行 最好是好看文档又全的，可以省很多事情。</p>
<p>*<em>①下载主题(<a href="https://hexo.io/themes/" target="_blank" rel="noopener">更多主题下载处</a>) *</em></p>
<p>打开终端在d:/hexo/bolg/themes目录下，输入如下命令下载主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Haojen/hexo-theme-Anisina.git</span><br></pre></td></tr></table></figure>

<p><strong>②配置主题 (<a href="http://haojen.github.io/2017/05/09/Anisina-中文使用教程/" target="_blank" rel="noopener">作者提供的api文档</a>)</strong></p>
<p>打开hexo/blog/_config.yml 文件</p>
<p>修改<code>themes: Anisina</code></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-a61f568d2e9bbee9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>修改主题</p>
]]></content>
  </entry>
  <entry>
    <title>supervisor介绍</title>
    <url>/2019/11/28/supervisor%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="supervisor介绍"><a href="#supervisor介绍" class="headerlink" title="supervisor介绍"></a>supervisor介绍</h1><h2 id="一、supervisor简介"><a href="#一、supervisor简介" class="headerlink" title="一、supervisor简介"></a>一、supervisor简介</h2><p>Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。</p>
<h2 id="二、supervisor安装"><a href="#二、supervisor安装" class="headerlink" title="二、supervisor安装"></a>二、supervisor安装</h2><ol>
<li><p>配置好yum源后，可以直接安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install supervisor</span><br></pre></td></tr></table></figure>
</li>
<li><p>Debian/Ubuntu可通过apt安装</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">apt-<span class="keyword">get</span> install supervisor</span><br></pre></td></tr></table></figure>
</li>
<li><p>pip安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure>
</li>
<li><p>easy_install安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">easy_install supervisor</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="三、supervisor使用"><a href="#三、supervisor使用" class="headerlink" title="三、supervisor使用"></a>三、supervisor使用</h2><h5 id="supervisor配置文件：-etc-supervisord-conf"><a href="#supervisor配置文件：-etc-supervisord-conf" class="headerlink" title="supervisor配置文件：/etc/supervisord.conf"></a>supervisor配置文件：<code>/etc/supervisord.conf</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*注：supervisor的配置文件默认是不全的，不过在大部分默认的情况下，上面说的基本功能已经满足。*</span><br></pre></td></tr></table></figure>

<h5 id="子进程配置文件路径：-etc-supervisord-d"><a href="#子进程配置文件路径：-etc-supervisord-d" class="headerlink" title="子进程配置文件路径：/etc/supervisord.d/"></a>子进程配置文件路径：<code>/etc/supervisord.d/</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*注：默认子进程配置文件为ini格式，可在supervisor主配置文件中修改。*</span><br></pre></td></tr></table></figure>

<h2 id="四、配置文件说明"><a href="#四、配置文件说明" class="headerlink" title="四、配置文件说明"></a>四、配置文件说明</h2><h4 id="supervisor-conf配置文件说明："><a href="#supervisor-conf配置文件说明：" class="headerlink" title="supervisor.conf配置文件说明："></a>supervisor.conf配置文件说明：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=<span class="number">0700</span>                 ;socket文件的mode，默认是<span class="number">0700</span></span><br><span class="line">;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid</span><br><span class="line"> </span><br><span class="line">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span><br><span class="line">;port=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9001</span>        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username=user              ;登录管理后台的用户名</span><br><span class="line">;password=<span class="number">123</span>               ;登录管理后台的密码</span><br><span class="line"> </span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.<span class="built_in">log</span> ;日志文件，默认是 $CWD/supervisord.<span class="built_in">log</span></span><br><span class="line">logfile_maxbytes=<span class="number">50</span>MB        ;日志文件大小，超出会rotate，默认 <span class="number">50</span>MB，如果设成<span class="number">0</span>，表示不限制大小</span><br><span class="line">logfile_backups=<span class="number">10</span>           ;日志文件保留备份数量默认<span class="number">10</span>，设为<span class="number">0</span>表示不备份</span><br><span class="line">loglevel=info                ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ;pid 文件</span><br><span class="line">nodaemon=<span class="literal">false</span>               ;是否在前台启动，默认是<span class="literal">false</span>，即以 daemon 的方式启动</span><br><span class="line">minfds=<span class="number">1024</span>                  ;可以打开的文件描述符的最小值，默认 <span class="number">1024</span></span><br><span class="line">minprocs=<span class="number">200</span>                 ;可以打开的进程数的最小值，默认 <span class="number">200</span></span><br><span class="line"> </span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:<span class="comment">///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span></span><br><span class="line">;serverurl=http:<span class="comment">//127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span></span><br><span class="line"> </span><br><span class="line">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span><br><span class="line">[program:xx]</span><br><span class="line">command=/opt/apache-tomcat<span class="number">-8.0</span><span class="number">.35</span>/bin/catalina.sh run  ; 程序启动命令</span><br><span class="line">autostart=<span class="literal">true</span>       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs=<span class="number">10</span>         ; 启动<span class="number">10</span>秒后没有异常退出，就表示进程正常启动了，默认为<span class="number">1</span>秒</span><br><span class="line">autorestart=<span class="literal">true</span>     ; 程序退出后自动重启,可选值：[unexpected,<span class="literal">true</span>,<span class="literal">false</span>]，默认为unexpected，表示进程意外杀死后才重启</span><br><span class="line">startretries=<span class="number">3</span>       ; 启动失败自动重试次数，默认是<span class="number">3</span></span><br><span class="line">user=tomcat          ; 用哪个用户启动进程，默认是root</span><br><span class="line">priority=<span class="number">999</span>         ; 进程启动优先级，默认<span class="number">999</span>，值小的优先启动</span><br><span class="line">redirect_stderr=<span class="literal">true</span> ; 把<span class="built_in">stderr</span>重定向到<span class="built_in">stdout</span>，默认<span class="literal">false</span></span><br><span class="line">stdout_logfile_maxbytes=<span class="number">20</span>MB  ; <span class="built_in">stdout</span> 日志文件大小，默认<span class="number">50</span>MB</span><br><span class="line">stdout_logfile_backups = <span class="number">20</span>   ; <span class="built_in">stdout</span> 日志文件备份数，默认是<span class="number">10</span></span><br><span class="line">; <span class="built_in">stdout</span> 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile=/opt/apache-tomcat<span class="number">-8.0</span><span class="number">.35</span>/logs/catalina.out</span><br><span class="line">stopasgroup=<span class="literal">false</span>     ;默认为<span class="literal">false</span>,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span><br><span class="line">killasgroup=<span class="literal">false</span>     ;默认为<span class="literal">false</span>，向进程组发送kill信号，包括子进程</span><br><span class="line"> </span><br><span class="line">;包含其它配置文件</span><br><span class="line">[include]</span><br><span class="line">files = relative/directory<span class="comment">/*.ini    ;可以指定一个或多个以.ini结束的配置文件</span></span><br></pre></td></tr></table></figure>

<h4 id="子进程配置文件说明："><a href="#子进程配置文件说明：" class="headerlink" title="子进程配置文件说明："></a>子进程配置文件说明：</h4><p>给需要管理的子进程(程序)编写一个配置文件，放在<code>/etc/supervisor.d/</code>目录下，以<code>.ini</code>作为扩展名（每个进程的配置文件都可以单独分拆也可以把相关的脚本放一起）。如任意定义一个和脚本相关的项目名称的选项组（/etc/supervisord.d/test.conf）：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#项目名</span></span><br><span class="line">[<span class="symbol">program:</span>blog]</span><br><span class="line"><span class="comment">#脚本目录</span></span><br><span class="line">directory=<span class="regexp">/opt/bin</span></span><br><span class="line"><span class="comment">#脚本执行命令</span></span><br><span class="line">command=<span class="regexp">/usr/bin</span><span class="regexp">/python /opt</span><span class="regexp">/bin/test</span>.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#supervisor启动的时候是否随着同时启动，默认True</span></span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line"><span class="comment">#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的</span></span><br><span class="line">autorestart=<span class="literal">false</span></span><br><span class="line"><span class="comment">#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1</span></span><br><span class="line">startsecs=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本运行的用户身份 </span></span><br><span class="line">user = test</span><br><span class="line"></span><br><span class="line"><span class="comment">#日志输出 </span></span><br><span class="line">stderr_logfile=<span class="regexp">/tmp/blog</span>_stderr.log </span><br><span class="line">stdout_logfile=<span class="regexp">/tmp/blog</span>_stdout.log </span><br><span class="line"><span class="comment">#把stderr重定向到stdout，默认 false</span></span><br><span class="line">redirect_stderr = <span class="literal">true</span></span><br><span class="line"><span class="comment">#stdout日志文件大小，默认 50MB</span></span><br><span class="line">stdout_logfile_maxbytes = <span class="number">20</span>M</span><br><span class="line"><span class="comment">#stdout日志文件备份数</span></span><br><span class="line">stdout_logfile_backups = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h5 id="子进程配置示例："><a href="#子进程配置示例：" class="headerlink" title="子进程配置示例："></a>子进程配置示例：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#说明同上</span></span><br><span class="line">[program:<span class="built_in">test</span>] </span><br><span class="line">directory=/opt/bin </span><br><span class="line"><span class="built_in">command</span>=/opt/bin/<span class="built_in">test</span></span><br><span class="line">autostart=<span class="literal">true</span> </span><br><span class="line">autorestart=<span class="literal">false</span> </span><br><span class="line">stderr_logfile=/tmp/test_stderr.log </span><br><span class="line">stdout_logfile=/tmp/test_stdout.log </span><br><span class="line"><span class="comment">#user = test</span></span><br></pre></td></tr></table></figure>



<h2 id="五、supervisor命令说明"><a href="#五、supervisor命令说明" class="headerlink" title="五、supervisor命令说明"></a>五、supervisor命令说明</h2><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">supervisorctl status        <span class="comment">//查看所有进程的状态</span></span><br><span class="line">supervisorctl stop es       <span class="comment">//停止es</span></span><br><span class="line">supervisorctl start es      <span class="comment">//启动es</span></span><br><span class="line">supervisorctl restart       <span class="comment">//重启es</span></span><br><span class="line">supervisorctl update        <span class="comment">//配置文件修改后使用该命令加载新的配置</span></span><br><span class="line">supervisorctl reload        <span class="comment">//重新启动配置中的所有程序</span></span><br></pre></td></tr></table></figure>

<p>注：把<code>es</code>换成<code>all</code>可以管理配置中的所有进程。直接输入<code>supervisorctl</code>进入supervisorctl的shell交互界面，此时上面的命令不带supervisorctl可直接使用。</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>使用supervisor进程管理命令之前先启动supervisord，否则程序报错。<br> 使用命令<code>supervisord -c /etc/supervisord.conf</code>启动。<br> 若是centos7：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">systemctl start supervisord.service     <span class="comment">//启动supervisor并加载默认配置文件</span></span><br><span class="line">systemctl enable supervisord.service    <span class="comment">//将supervisor加入开机启动项</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>git服务搭建</title>
    <url>/2019/11/28/git%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="创建用户账号"><a href="#创建用户账号" class="headerlink" title="创建用户账号"></a>创建用户账号</h1><p>添加用户： useradd  test_user</p>
<p>设置密码： passwd test_user </p>
<p>登录： ssh <a href="mailto:test_user@62.234.92.111" target="_blank" rel="noopener">test_user@62.234.92.111</a>          命令格式：     ssh    用户名@ip地址</p>
<h1 id="使用公钥私钥登录"><a href="#使用公钥私钥登录" class="headerlink" title="使用公钥私钥登录"></a>使用公钥私钥登录</h1><h2 id="配置sshd服务参数"><a href="#配置sshd服务参数" class="headerlink" title="配置sshd服务参数"></a>配置sshd服务参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line">RSAAuthentication yes   # 启用RSA 非对称加密算法</span><br><span class="line">PubkeyAuthentication yes   # 公钥认证</span><br><span class="line">PasswordAuthentication yes  #允许密码认证</span><br></pre></td></tr></table></figure>

<p>修改配置后需要重启服务：  systemctl restart sshd.service</p>
<h2 id="创建ssh权限目录和文件"><a href="#创建ssh权限目录和文件" class="headerlink" title="创建ssh权限目录和文件"></a>创建ssh权限目录和文件</h2><p>生成公钥私钥： ssh-keygen</p>
<p>切换用户   su - test_user</p>
<p>创建文件夹：  mkdir .ssh   </p>
<p>设置.ssh目录权限   chmod 700 .ssh</p>
<p>创建文件： touch .ssh/authorized_keys</p>
<p>设置authorized_keys权限   chmod 600 .ssh/authorized_keys</p>
<p>使用证书登录   ssh <a href="mailto:test_user@62.234.92.111" target="_blank" rel="noopener">test_user@62.234.92.111</a>   -i 证书路径</p>
<h1 id="搭建git服务"><a href="#搭建git服务" class="headerlink" title="搭建git服务"></a>搭建git服务</h1><p>创建git用户    useradd git</p>
<p>设置git用户ssh权限目录和文件</p>
<p>创建一个裸版本库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - git                            # 登录git用户</span><br><span class="line">git init --bare project.git         # 创建一个裸仓库</span><br></pre></td></tr></table></figure>



<h2 id="创建一个文件并提交"><a href="#创建一个文件并提交" class="headerlink" title="创建一个文件并提交"></a>创建一个文件并提交</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch readme.txt                          # 创建readme.txt 文件</span><br><span class="line">git add readme.txt                         # 添加到暂存区中 </span><br><span class="line">git commit -m &quot;添加readme文件&quot;              # 提交到本地版本库里</span><br><span class="line">git push origin                            # 推送到远程仓库</span><br><span class="line">git pull origin                           # 拉取文件</span><br></pre></td></tr></table></figure>



<h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git</span><br></pre></td></tr></table></figure>









]]></content>
  </entry>
  <entry>
    <title>微信小程序代码规范</title>
    <url>/2019/11/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h5 id="微信小程序里的四种文件"><a href="#微信小程序里的四种文件" class="headerlink" title="微信小程序里的四种文件"></a>微信小程序里的四种文件</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.json</span> 后缀的 <span class="selector-tag">JSON</span> 配置文件</span><br><span class="line"><span class="selector-class">.wxml</span> 后缀的 <span class="selector-tag">WXML</span> 模板文件</span><br><span class="line"><span class="selector-class">.wxss</span> 后缀的 <span class="selector-tag">WXSS</span> 样式文件</span><br><span class="line"><span class="selector-class">.js</span> 后缀的 <span class="selector-tag">JS</span> 脚本逻辑文件</span><br></pre></td></tr></table></figure>

<h5 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 图片资源</span></span><br><span class="line">目前图片资源的主要性能问题在于大图片和长列表图片上，</span><br><span class="line">这两种情况都有可能导致 iOS 客户端内存占用上升，</span><br><span class="line">从而触发系统回收小程序页面。</span><br><span class="line"><span class="meta">### 图片对内存的影响</span></span><br><span class="line">在 iOS 上，小程序的页面是由多个 <span class="built_in">WKWebView</span> 组成的，</span><br><span class="line">在系统内存紧张时，会回收掉一部分 <span class="built_in">WKWebView</span>。</span><br><span class="line">从过去我们分析的案例来看，大图片和长列表图片的使用会引起 <span class="built_in">WKWebView</span> 的回收。</span><br><span class="line"><span class="meta">### 图片对页面切换的影响</span></span><br><span class="line">除了内存问题外，大图片也会造成页面切换的卡顿。</span><br><span class="line">我们分析过的案例中，有一部分小程序会在页面中引用大图片，</span><br><span class="line">在页面后退切换中会出现掉帧卡顿的情况。</span><br><span class="line">当前我们建议开发者尽量减少使用大图片资源。</span><br></pre></td></tr></table></figure>

<h5 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">所有资源文件(如图片)放在统一文件下及其子文件中(例如以下分类)</span><br><span class="line">resource</span><br><span class="line">  ——<span class="keyword">public</span></span><br><span class="line">  ——tab</span><br><span class="line">  ——home</span><br><span class="line">  ——mine</span><br></pre></td></tr></table></figure>

<h5 id="基础页面"><a href="#基础页面" class="headerlink" title="基础页面"></a>基础页面</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">业务展示的页面放在如 pages 文件及其子文件中(例如以下分类)</span><br><span class="line">pages</span><br><span class="line">  ——index</span><br><span class="line">  ——mall</span><br><span class="line">    ——goodList</span><br><span class="line">    ——goodDetail</span><br><span class="line">  ——order</span><br><span class="line">    ——orderList</span><br><span class="line">    ——orderDetail</span><br><span class="line">  ——mine</span><br><span class="line">    ——myInfo</span><br><span class="line">    ——myAddress</span><br><span class="line">    </span><br><span class="line">如有其他子业务，单独在pages里创建新的子级文件</span><br><span class="line">注释规范</span><br><span class="line">   针对wxml页面由上到下(或由左到右)分级的模块，均需注释出其功能，</span><br><span class="line">   并在其上下空出一行与其他代码进行区分。</span><br></pre></td></tr></table></figure>

<h5 id="样式文件"><a href="#样式文件" class="headerlink" title="样式文件"></a>样式文件</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">基础样式文件，在最外层中创建(如：<span class="selector-tag">weui</span><span class="selector-class">.wxss</span>)</span><br><span class="line">第一步：写入公共样式：如 </span><br><span class="line">1.标题字体大小，描述字体大小等项目中一二三级字号；</span><br><span class="line">2.程序中所用的公共色值；</span><br><span class="line">3.布局方式<span class="selector-tag">flex</span>的横向布局，纵向布局等；</span><br><span class="line">4.公共布局中<span class="selector-tag">wxss</span>样式前缀统一(如<span class="selector-tag">weui-</span>开头)；</span><br><span class="line">等等</span><br><span class="line"></span><br><span class="line">第二步：在<span class="selector-tag">app</span><span class="selector-class">.wxss</span>文件最上部，引入 @<span class="keyword">import</span> <span class="string">"weui.wxss"</span>;</span><br><span class="line">以上公共样式便可全局使用</span><br><span class="line"><span class="selector-tag">wxss</span>规范</span><br><span class="line">    1<span class="selector-class">.wxss</span> 页面可使用快捷键真理代码(<span class="selector-tag">Shift</span>+<span class="selector-tag">Alt</span>+<span class="selector-tag">F</span>)</span><br><span class="line">    整理后代码有明显的代码缩进，对齐。每一个样式类之间空出一行；</span><br><span class="line"></span><br><span class="line">    2.在开发过程中<span class="selector-tag">rpx</span>和<span class="selector-tag">px</span>均可能用到，</span><br><span class="line">    如通常情况下间距使用<span class="selector-tag">rpx</span>，</span><br><span class="line">    字体大小和边框等使用<span class="selector-tag">px</span>，开发者根据实际情况而定；</span><br><span class="line">       </span><br><span class="line">    3.同一块的样式属性(如 <span class="selector-class">.order-title</span> 和 <span class="selector-class">.order-image</span>)放在一块；</span><br><span class="line">    </span><br><span class="line">    4<span class="selector-class">.wxss</span> 样式中同一块可以这样抒写(如 <span class="selector-class">.order</span><span class="selector-class">.title</span>)</span><br><span class="line">    意思是<span class="selector-class">.order</span>样式下的<span class="selector-class">.title</span>,</span><br><span class="line">    其他地方的class='title'不会引用到.order下的.title</span><br><span class="line">    </span><br><span class="line">    5<span class="selector-class">.wxss</span>样式之间用块状注释。请勿在代码后面直接注释。</span><br></pre></td></tr></table></figure>

<h5 id="JS规范"><a href="#JS规范" class="headerlink" title="JS规范"></a>JS规范</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">JS规范</span><br><span class="line">    <span class="number">1.</span>删除js文件中未用到的生命周期函数，保持代码的整洁</span><br><span class="line">    <span class="number">2.</span>右上角不要分享的页面，删除JS文件中该方法onShareAppMessage:function()</span><br><span class="line">    <span class="number">3.</span>采用ES6 关键字<span class="keyword">let</span>定义变量，尽量不使用<span class="keyword">var</span></span><br><span class="line">    <span class="number">4.</span>所有涉及到数据绑定的变量均需在data中初始化,禁止在不定义的情况下直接setData</span><br><span class="line">    <span class="number">5.</span>变量名以及函数名统一采用驼峰命名法(或下划线分割)</span><br><span class="line">    <span class="number">6.</span>正常情况下函数名前缀需加上清晰的动词表示函数功能(如getOderList)</span><br><span class="line">    <span class="number">7.</span>点击事件函数命名方式为 <span class="keyword">on</span> + 事件名 或者业务名</span><br><span class="line">    <span class="number">8.</span>JS语句无需以分号结束，统一省略分号</span><br><span class="line">    <span class="number">9.</span>JS中一致使用单引号<span class="string">' '</span> , WXML中一致使用双引号<span class="string">" "</span></span><br></pre></td></tr></table></figure>



<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>一个ES6的模块是一个包含了js代码的文件。<strong>ES6里没有所谓的module关键字，一个模块就是一个普通的脚本文件</strong>，除了以下两个区别：</p>
<p>\1. ES6中的模块自动开启严格模式。<br>\2. 模块中可以使用import和export。</p>
<p><strong>导入和导出</strong></p>
<p>我们可以通过import和export关键字将函数或<strong>对象导入和导出模块</strong>。<br>先来说说export，在模块中声明的任何东西都是默认私有的，<strong>如果想对其他模块public，必须将那部分代码export</strong>。最简单的方法就是添加一个export关键字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`// kittydar.js`</span><span class="string">`export `</span><span class="string">`function`</span> <span class="string">`detectCats(canvas, options) &#123;`</span><span class="string">`var`</span> <span class="string">`kittydar = `</span><span class="string">`new`</span> <span class="string">`Kittydar(options);`</span><span class="string">`return`</span> <span class="string">`kittydar.detectCats(canvas);`</span><span class="string">`&#125;`</span><span class="string">`export class Kittydar &#123;`</span><span class="string">`... several methods doing image processing ...`</span><span class="string">`&#125;`</span><span class="string">`// This helper function isn't exported.`</span><span class="string">`function`</span> <span class="string">`resizeCanvas() &#123;`</span><span class="string">`...`</span><span class="string">`&#125;`</span><span class="string">`...`</span></span><br></pre></td></tr></table></figure>

<p>不再有跨文件或跨模块的全局变量，<strong>export声明的那部分就是这个模块的public API</strong>。而在另外一个文件中，我们可以导入这个模块并且使用detectCat方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`// demo.js - Kittydar demo program`</span><span class="string">`import &#123;detectCats&#125; from `</span><span class="string">`"kittydar.js"`</span><span class="string">`;`</span><span class="string">`function`</span> <span class="string">`go() &#123;`</span><span class="string">`var`</span> <span class="string">`canvas = document.getElementById(`</span><span class="string">`"catpix"`</span><span class="string">`);`</span><span class="string">`var`</span> <span class="string">`cats = detectCats(canvas);`</span><span class="string">`drawRectangles(canvas, cats);`</span><span class="string">`&#125;`</span></span><br></pre></td></tr></table></figure>

<p>如果需要导入多个模块中的接口，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`import &#123;detectCats, Kittydar&#125; from `</span><span class="string">`"kittydar.js"`</span><span class="string">`;`</span></span><br></pre></td></tr></table></figure>

<p>我们也可以通过一行代码将本模块所有需要public的方法公开：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`export &#123;detectCats, Kittydar&#125;;`</span></span><br></pre></td></tr></table></figure>

<p>这样就不用一个个地添加export关键字了。</p>
<p><strong>命名冲突</strong></p>
<p>上面介绍了模块中的导入和导出，那么如果导入的变量名和模块中的变量名冲突了应该如何是好呢？放心，<strong>ES6允许我们为导入的内容重命名</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`import &#123;flip as flipOmelet&#125; from `</span><span class="string">`"eggs.js"`</span><span class="string">`;`</span><span class="string">`import &#123;flip as flipHouse&#125; from `</span><span class="string">`"real-estate.js"`</span><span class="string">`;`</span></span><br></pre></td></tr></table></figure>

<p>这样就将从eggs模块来的<strong>flip改为了flipOmelet</strong>，从real-estate模块来的<strong>flip改为了flipHouse</strong>，从而避免了冲突。</p>
<p>同样的，我们也可以在模块导出变量名时进行重命名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`function`</span> <span class="string">`v1() &#123; ... &#125;`</span><span class="string">`function`</span> <span class="string">`v2() &#123; ... &#125;`</span><span class="string">`export &#123;`</span><span class="string">`v1 as streamV1,`</span><span class="string">`v2 as streamV2,`</span><span class="string">`v2 as streamLatestVersion`</span><span class="string">`&#125;;`</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>python开发规范</title>
    <url>/2016/09/25/python%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p><img src="/2016/09/25/python%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/default.jpg" alt="123"></p>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>Tip</p>
<p>不要在行尾加分号, 也不要用分号将两条命令放在同一行.</p>
<h2 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h2><p>Tip</p>
<p>每行不超过80个字符</p>
<p>例外:</p>
<ol>
<li>长的导入模块语句</li>
<li>注释里的URL</li>
</ol>
<p>不要使用反斜杠连接行.</p>
<p>Python会将 <a href="http://docs.python.org/2/reference/lexical_analysis.html#implicit-line-joining" target="_blank" rel="noopener">圆括号, 中括号和花括号中的行隐式的连接起来</a> , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: foo_bar(self, width, height, color=<span class="string">'black'</span>, design=<span class="literal">None</span>, x=<span class="string">'foo'</span>,</span><br><span class="line">             emphasis=<span class="literal">None</span>, highlight=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (width == <span class="number">0</span> <span class="keyword">and</span> height == <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">         color == <span class="string">'red'</span> <span class="keyword">and</span> emphasis == <span class="string">'strong'</span>):</span><br></pre></td></tr></table></figure>

<p>如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = (<span class="string">'This will build a very long long '</span></span><br><span class="line">     <span class="string">'long long long long long long string'</span>)</span><br></pre></td></tr></table></figure>

<p>在注释中，如果必要，将长的URL放在一行上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:  <span class="comment"># See details at</span></span><br><span class="line">      <span class="comment"># http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html</span></span><br><span class="line">No:  <span class="comment"># See details at</span></span><br><span class="line">     <span class="comment"># http://www.example.com/us/developer/documentation/api/content/\</span></span><br><span class="line">     <span class="comment"># v2.0/csv_file_name_extension_full_specification.html</span></span><br></pre></td></tr></table></figure>

<p>注意上面例子中的元素缩进; 你可以在本文的 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/#indentation" target="_blank" rel="noopener">缩进</a> 部分找到解释.</p>
<h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><p>Tip</p>
<p>宁缺毋滥的使用括号</p>
<p>除非是用于实现行连接, 否则不要在返回语句或条件语句中使用括号. 不过在元组两边使用括号是可以的.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> foo:</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">while</span> x:</span><br><span class="line">         x = bar()</span><br><span class="line">     <span class="keyword">if</span> x <span class="keyword">and</span> y:</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">return</span> foo</span><br><span class="line">     <span class="keyword">for</span> (x, y) <span class="keyword">in</span> dict.items(): ...</span><br><span class="line">No:  <span class="keyword">if</span> (x):</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span>(x):</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">return</span> (foo)</span><br></pre></td></tr></table></figure>



<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>Tip</p>
<p>用4个空格来缩进代码</p>
<p>绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素(见 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/#line-length" target="_blank" rel="noopener">行长度</a> 部分的示例), 或者使用4空格的悬挂式缩进(这时第一行不应该有参数):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:   <span class="comment"># Aligned with opening delimiter</span></span><br><span class="line">       foo = long_function_name(var_one, var_two,</span><br><span class="line">                                var_three, var_four)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># Aligned with opening delimiter in a dictionary</span></span><br><span class="line">       foo = &#123;</span><br><span class="line">           long_dictionary_key: value1 +</span><br><span class="line">                                value2,</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 4-space hanging indent; nothing on first line</span></span><br><span class="line">       foo = long_function_name(</span><br><span class="line">           var_one, var_two, var_three,</span><br><span class="line">           var_four)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 4-space hanging indent in a dictionary</span></span><br><span class="line">       foo = &#123;</span><br><span class="line">           long_dictionary_key:</span><br><span class="line">               long_dictionary_value,</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">No:    <span class="comment"># Stuff on first line forbidden</span></span><br><span class="line">      foo = long_function_name(var_one, var_two,</span><br><span class="line">          var_three, var_four)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 2-space hanging indent forbidden</span></span><br><span class="line">      foo = long_function_name(</span><br><span class="line">        var_one, var_two, var_three,</span><br><span class="line">        var_four)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># No hanging indent in a dictionary</span></span><br><span class="line">      foo = &#123;</span><br><span class="line">          long_dictionary_key:</span><br><span class="line">              long_dictionary_value,</span><br><span class="line">              ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>Tip</p>
<p>顶级定义之间空两行, 方法定义之间空一行</p>
<p>顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.</p>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>Tip</p>
<p>按照标准的排版规范来使用标点两边的空格</p>
<p>括号内不要有空格.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: spam(ham[<span class="number">1</span>], &#123;eggs: <span class="number">2</span>&#125;, [])</span><br><span class="line">No:  spam( ham[ <span class="number">1</span> ], &#123; eggs: <span class="number">2</span> &#125;, [ ] )</span><br></pre></td></tr></table></figure>

<p>不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> x == <span class="number">4</span>:</span><br><span class="line">         <span class="keyword">print</span> x, y</span><br><span class="line">     x, y = y, x</span><br><span class="line">No:  <span class="keyword">if</span> x == <span class="number">4</span> :</span><br><span class="line">         <span class="keyword">print</span> x , y</span><br><span class="line">     x , y = y , x</span><br></pre></td></tr></table></figure>

<p>参数列表, 索引或切片的左括号前不应加空格.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: spam(<span class="number">1</span>)</span><br><span class="line">no: spam (<span class="number">1</span>)</span><br><span class="line">Yes: dict[<span class="string">'key'</span>] = list[index]</span><br><span class="line">No:  dict [<span class="string">'key'</span>] = list [index]</span><br></pre></td></tr></table></figure>

<p>在二元操作符两边都加上一个空格, 比如赋值(=), 比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not), 布尔(and, or, not). 至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: x == <span class="number">1</span></span><br><span class="line">No:  x&lt;<span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>当’=’用于指示关键字参数或默认参数值时, 不要在其两侧使用空格.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag=<span class="number">0.0</span>)</span>:</span> <span class="keyword">return</span> magic(r=real, i=imag)</span><br><span class="line">No:  <span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag = <span class="number">0.0</span>)</span>:</span> <span class="keyword">return</span> magic(r = real, i = imag)</span><br></pre></td></tr></table></figure>

<p>不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:</span><br><span class="line">     foo = <span class="number">1000</span>  <span class="comment"># comment</span></span><br><span class="line">     long_name = <span class="number">2</span>  <span class="comment"># comment that should not be aligned</span></span><br><span class="line"></span><br><span class="line">     dictionary = &#123;</span><br><span class="line">         <span class="string">"foo"</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="string">"long_name"</span>: <span class="number">2</span>,</span><br><span class="line">         &#125;</span><br><span class="line">No:</span><br><span class="line">     foo       = <span class="number">1000</span>  <span class="comment"># comment</span></span><br><span class="line">     long_name = <span class="number">2</span>     <span class="comment"># comment that should not be aligned</span></span><br><span class="line"></span><br><span class="line">     dictionary = &#123;</span><br><span class="line">         <span class="string">"foo"</span>      : <span class="number">1</span>,</span><br><span class="line">         <span class="string">"long_name"</span>: <span class="number">2</span>,</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Tip</p>
<p>确保对模块, 函数, 方法和行内注释使用正确的风格</p>
<p><strong>文档字符串</strong></p>
<blockquote>
<p>Python有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的<strong>doc</strong>成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号”“”( <a href="http://www.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">PEP-257</a> ). 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范.</p>
</blockquote>
<p><strong>模块</strong></p>
<blockquote>
<p>每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板.</p>
</blockquote>
<p><strong>函数和方法</strong></p>
<blockquote>
<p>下文所指的函数,包括函数, 方法, 以及生成器.</p>
<p>一个函数必须要有文档字符串, 除非它满足以下条件:</p>
<ol>
<li>外部不可见</li>
<li>非常短小</li>
<li>简单明了</li>
</ol>
<p>文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述”怎么做”, 除非是一些复杂的算法. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有意义.</p>
<p>关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述. 每节应该以一个标题行开始. 标题行以冒号结尾. 除标题行外, 节的其他内容应被缩进2个空格.</p>
<ul>
<li><p>Args:</p>
<p>列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受<em>foo(可变长度参数列表)或者*</em>bar (任意关键字参数), 应该详细列出<em>foo和*</em>bar.</p>
</li>
<li><p>Returns: (或者 Yields: 用于生成器)</p>
<p>描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略.</p>
</li>
<li><p>Raises:</p>
<p>列出与接口有关的所有异常.</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_bigtable_rows</span><span class="params">(big_table, keys, other_silly_variable=None)</span>:</span></span><br><span class="line">    <span class="string">"""Fetches rows from a Bigtable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Retrieves rows pertaining to the given keys from the Table instance</span></span><br><span class="line"><span class="string">    represented by big_table.  Silly things may happen if</span></span><br><span class="line"><span class="string">    other_silly_variable is not None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        big_table: An open Bigtable Table instance.</span></span><br><span class="line"><span class="string">        keys: A sequence of strings representing the key of each table row</span></span><br><span class="line"><span class="string">            to fetch.</span></span><br><span class="line"><span class="string">        other_silly_variable: Another optional variable, that has a much</span></span><br><span class="line"><span class="string">            longer name than the other args, and which does nothing.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        A dict mapping keys to the corresponding table row data</span></span><br><span class="line"><span class="string">        fetched. Each row is represented as a tuple of strings. For</span></span><br><span class="line"><span class="string">        example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#123;'Serak': ('Rigel VII', 'Preparer'),</span></span><br><span class="line"><span class="string">         'Zim': ('Irk', 'Invader'),</span></span><br><span class="line"><span class="string">         'Lrrr': ('Omicron Persei 8', 'Emperor')&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If a key from the keys argument is missing from the dictionary,</span></span><br><span class="line"><span class="string">        then that row was not found in the table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        IOError: An error occurred accessing the bigtable.Table object.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>类</strong></p>
<blockquote>
<p>类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Summary of class here.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Longer class information....</span></span><br><span class="line"><span class="string">    Longer class information....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        likes_spam: A boolean indicating if we like SPAM or not.</span></span><br><span class="line"><span class="string">        eggs: An integer count of the eggs we have laid.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, likes_spam=False)</span>:</span></span><br><span class="line">        <span class="string">"""Inits SampleClass with blah."""</span></span><br><span class="line">        self.likes_spam = likes_spam</span><br><span class="line">        self.eggs = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Performs operation blah."""</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>块注释和行注释</strong></p>
<blockquote>
<p>最需要写注释的是代码中那些技巧性的部分. 如果你在下次 <a href="http://en.wikipedia.org/wiki/Code_review" target="_blank" rel="noopener">代码审查</a> 的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># We use a weighted dictionary search to find out where i is in</span></span><br><span class="line"><span class="comment"># the array.  We extrapolate position based on the largest num</span></span><br><span class="line"><span class="comment"># in the array and the array size and then do binary search to</span></span><br><span class="line"><span class="comment"># get the exact number.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &amp; (i<span class="number">-1</span>) == <span class="number">0</span>:        <span class="comment"># True if i is 0 or a power of 2.</span></span><br></pre></td></tr></table></figure>

<p>为了提高可读性, 注释应该至少离开代码2个空格.</p>
<p>另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BAD COMMENT: Now go through the b array and make sure whenever i occurs</span></span><br><span class="line"><span class="comment"># the next element is i+1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Tip</p>
<p>如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span></span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">         <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span><span class="params">(object)</span>:</span></span><br><span class="line">             <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span><span class="params">(ParentClass)</span>:</span></span><br><span class="line">         <span class="string">"""Explicitly inherits from another class already."""</span></span><br><span class="line">No: <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>继承自 <code>object</code> 是为了使属性(properties)正常工作, 并且这样可以保护你的代码, 使其不受 <a href="http://www.python.org/dev/peps/pep-3000/" target="_blank" rel="noopener">PEP-3000</a> 的一个特殊的潜在不兼容性影响. 这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 包括 <code>__new__, __init__, __delattr__, __getattribute__, __setattr__, __hash__, __repr__, and __str__</code> .</p>
<h2 id="导入格式"><a href="#导入格式" class="headerlink" title="导入格式"></a>导入格式</h2><p>Tip</p>
<p>每个导入应该独占一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对的 </span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#错的</span></span><br><span class="line"><span class="keyword">import</span> os, sys</span><br></pre></td></tr></table></figure>

<p>导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组:</p>
<ol>
<li>标准库导入</li>
<li>第三方库导入</li>
<li>应用程序指定导入</li>
</ol>
<p>每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo</span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br><span class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> baz</span><br><span class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> Quux</span><br><span class="line"><span class="keyword">from</span> Foob <span class="keyword">import</span> ar</span><br></pre></td></tr></table></figure>

<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>Tip</p>
<p>通常每个语句应该独占一行</p>
<p>不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行. 如果是if语句, 只有在没有else时才能这样做. 特别地, 绝不要对 <code>try/except</code> 这样做, 因为try和except不能放在同一行.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对的</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> foo: bar(foo)</span><br><span class="line"><span class="comment">#错的</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> foo: bar(foo)</span><br><span class="line">  <span class="keyword">else</span>:   baz(foo)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>:               bar(foo)</span><br><span class="line">  <span class="keyword">except</span> ValueError: baz(foo)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      bar(foo)</span><br><span class="line">  <span class="keyword">except</span> ValueError: baz(foo)</span><br></pre></td></tr></table></figure>



<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name.</p>
<p><strong>应该避免的名称</strong></p>
<blockquote>
<ol>
<li>单字符名称, 除了计数器和迭代器.</li>
<li>包/模块名中的连字符(-)</li>
<li>双下划线开头并结尾的名称(Python保留, 例如<strong>init</strong>)</li>
</ol>
</blockquote>
<p><strong>命名约定</strong></p>
<blockquote>
<ol>
<li>所谓”内部(Internal)”表示仅模块内可用, 或者, 在类内是保护或私有的.</li>
<li>用单下划线(_)开头表示模块变量或函数是protected的(使用from module import *时不会包含).</li>
<li>用双下划线(__)开头的实例变量或方法表示类内私有.</li>
<li>将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.</li>
<li>对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.</li>
</ol>
</blockquote>
<p><strong>Python之父Guido推荐的规范</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Public</th>
<th>Internal</th>
</tr>
</thead>
<tbody><tr>
<td>Modules</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr>
<td>Packages</td>
<td>lower_with_under</td>
<td></td>
</tr>
<tr>
<td>Classes</td>
<td>CapWords</td>
<td>_CapWords</td>
</tr>
<tr>
<td>Exceptions</td>
<td>CapWords</td>
<td></td>
</tr>
<tr>
<td>Functions</td>
<td>lower_with_under()</td>
<td>_lower_with_under()</td>
</tr>
<tr>
<td>Global/Class Constants</td>
<td>CAPS_WITH_UNDER</td>
<td>_CAPS_WITH_UNDER</td>
</tr>
<tr>
<td>Global/Class Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr>
<td>Instance Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under (protected) or __lower_with_under (private)</td>
</tr>
<tr>
<td>Method Names</td>
<td>lower_with_under()</td>
<td>_lower_with_under() (protected) or __lower_with_under() (private)</td>
</tr>
<tr>
<td>Function/Method Parameters</td>
<td>lower_with_under</td>
<td></td>
</tr>
<tr>
<td>Local Variables</td>
<td>lower_with_under</td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
</search>
