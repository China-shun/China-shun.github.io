<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>在阿里云Centos云服务器上部署mysql数据库</title>
    <url>/2019/11/28/%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91Centos%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>layout: article</p>
<p>title: 在阿里云Centos云服务器上部署mysql数据库<br>date: 2018-4-23</p>
<h1 id="在阿里云Centos云服务器上部署mysql数据库"><a href="#在阿里云Centos云服务器上部署mysql数据库" class="headerlink" title="在阿里云Centos云服务器上部署mysql数据库"></a>在阿里云Centos云服务器上部署mysql数据库</h1><blockquote>
<p>首先查看centos7上有没有安装过mysql ,一定要卸载干净残留，不然会安装或启动失败。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list installed mysql*</span><br><span class="line">列出后如果有就删除</span><br></pre></td></tr></table></figure>

<ul>
<li><em>删除mysql</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum remove mysql-community-*</span><br><span class="line">rm -rf /var/lib/mysql</span><br><span class="line">rm /etc/my.cnf</span><br></pre></td></tr></table></figure>

<ul>
<li><em>安装yum源</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm</span><br><span class="line">sudo yum instal   mysql80-community-release-el7-1.noarch.rpm</span><br></pre></td></tr></table></figure>

<ul>
<li><em>查看是否安装成功</em></li>
</ul>
<p><code>sudo yum repolist all|grep mysql</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2067965-8277cf35d4e8c628.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/688/format/webp" alt="img"></p>
<p>成功安装</p>
<ul>
<li><em>配置要安装的mysql版本</em></li>
</ul>
<p><code>sudo vim /etc/yum.repos.d/mysql-community.repo</code></p>
<p><strong>enabled 为1表示启用，将要安装的版本的enabled改为1后保存</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2067965-c7fedc62b2bab299.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/657/format/webp" alt="img"></p>
<p>配置repo</p>
<ul>
<li><em>安装启动mysql</em><br><code>sudo yum install mysql-community-server.x86_64</code></li>
</ul>
<p><em>等待安装好后启动mysql</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service mysqld start      //启动mysql</span><br><span class="line">sudo service mysqld status   //查看mysql状态</span><br><span class="line">sudo systemctl enable mysqld //配置开机启动</span><br></pre></td></tr></table></figure>

<ul>
<li><em>管理账户</em></li>
</ul>
<p><em>mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log  //找到默认密码</span><br><span class="line">mysql -uroot -p </span><br><span class="line">set password for &apos;root&apos;@&apos;localhost&apos;=password(&apos;NEWPASSWORD&apos;); 或者ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;NEWPASSWORD&apos;;  // 修改密码,注意密码要复杂一些，否则会不能通过。</span><br></pre></td></tr></table></figure>

<ul>
<li><em>添加远程用户</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;username&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<ul>
<li><em>查看并修改编码</em></li>
</ul>
<p><code>mysql -u root -p</code><br><code>show variables like &#39;%char%;</code><br>看到有的编码不是 <code>utf8</code><br><em>更改配置文件</em><br><code>vim /etc/my.cnf</code><br><em>在[mysqld]下面添加以下两句</em></p>
<p><code>character_set_server=utf8</code><br><code>collation-server=utf8_general_ci</code><br><em>在[client]下面添加</em><br><code>default-character-set=utf8</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2067965-d4e266a5524f9690.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/427/format/webp" alt="img"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2067965-c386fc983b323d5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/715/format/webp" alt="img"></p>
<p>修改成功</p>
<p><strong>注意修改后只会对以后创建的数据库生效。</strong></p>
<p>然后登陆阿里云配置安全组</p>
<ul>
<li><p>通过实例列表选中服务器后，进入实例详情页面</p>
</li>
<li><p>在左侧点击<strong>本实例安全组</strong></p>
</li>
<li><p>在安全组列表里选中你的服务器实例</p>
</li>
<li><p>页面默认会在<strong>安全组规则</strong>分页中</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006Z3bUvly1g9ahndkb6dj31hc0eldh8.jpg" alt="微信截图_20191125185914.png"></p>
<p>如图所示</p>
<p><img src="http://ww1.sinaimg.cn/large/006Z3bUvly1g9ahoa3tt8j30gm0ifgm2.jpg" alt="微信截图_20191125190055.png">)<img src="http://ww1.sinaimg.cn/large/006Z3bUvly1g9ahohopf7j31au09v74u.jpg" alt="微信截图_20191125190121.png">)<img src="http://ww1.sinaimg.cn/large/006Z3bUvly1g9ahonlotjj31au09a0t2.jpg" alt="微信截图_20191125190133.png"></p>
<p>这样配置应该就会成功了</p>
]]></content>
  </entry>
  <entry>
    <title>微信小程序-注册整体过程</title>
    <url>/2019/04/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%B3%A8%E5%86%8C%E6%95%B4%E4%BD%93%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="微信小程序-注册整体过程"><a href="#微信小程序-注册整体过程" class="headerlink" title="微信小程序-注册整体过程"></a>微信小程序-注册整体过程</h1><h2 id="reg-wxml"><a href="#reg-wxml" class="headerlink" title="reg.wxml"></a>reg.wxml</h2><p><img src="/2019/04/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%B3%A8%E5%86%8C%E6%95%B4%E4%BD%93%E8%BF%87%E7%A8%8B/C:%5CUsers%5Cshun%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574651962596.png" alt="1574651962596"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;view class=&quot;row&quot;&gt;</span><br><span class="line">  # &lt;input class=&quot;info-input&quot; placeholder=&quot;请输入用户名&quot; bindinput=&quot;name&quot;&gt;&lt;/input&gt;</span><br><span class="line">    &lt;input class=&quot;info-input&quot; placeholder=&quot;请输入用户名&quot; bindchange=&quot;name&quot;&gt;&lt;/input&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view class=&apos;row&apos;&gt;</span><br><span class="line">    &lt;view class=&apos;info&apos;&gt;</span><br><span class="line">   #&lt;input class=&quot;info-input&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; bindinput=&quot;password&quot;&gt;&lt;/input&gt;</span><br><span class="line">    &lt;input class=&quot;info-input&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; bindchange=&quot;password&quot;&gt;&lt;/input&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;button class=&quot;submit&quot; bindtap=&quot;reg&quot;&gt;注册&lt;/button&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<h2 id="reg-js"><a href="#reg-js" class="headerlink" title="reg.js"></a>reg.js</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// miniprogram/pages/reg/reg.js</span><br><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 页面的初始数据</span><br><span class="line">   */</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &apos;&apos;,</span><br><span class="line">    password: &apos;&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  //获取用户输入的用户名</span><br><span class="line">  name: function (n) &#123;</span><br><span class="line">    // debugger</span><br><span class="line">    var content = n.detail.value</span><br><span class="line">    this.setData(&#123;  </span><br><span class="line">      name: content,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"> //获取用户输入的密码</span><br><span class="line">  password: function (e) &#123;</span><br><span class="line">    var pwd = e.detail.value;</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      password: pwd,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  # 绑定的点击事件</span><br><span class="line">  reg: function () &#123;</span><br><span class="line">    // debugger</span><br><span class="line">    console.log(this.data)</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: &apos;http://127.0.0.1:8000/app/reg/&apos;,</span><br><span class="line">      method: &apos;post&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        &apos;name&apos;: this.data.name,</span><br><span class="line">        &apos;password&apos;: this.data.password</span><br><span class="line">      &#125;,</span><br><span class="line">      header: &#123;</span><br><span class="line">        // &apos;content-type&apos;: &apos;application/json&apos;    //get 方式</span><br><span class="line">        &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line">        if(res.data.code==200)&#123;</span><br><span class="line">          console.log(res)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          console.log(res)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Django后台接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#注册</span><br><span class="line">class reg(APIView):</span><br><span class="line">    def post(self,request):</span><br><span class="line">    	# 获取用户名 密码</span><br><span class="line">        name=request.data[&quot;name&quot;]</span><br><span class="line">        password=request.data[&quot;password&quot;]</span><br><span class="line">        if not all([name,password]):</span><br><span class="line">            return Response(&#123;</span><br><span class="line">                &quot;code&quot;:201,</span><br><span class="line">                &quot;message&quot;:&quot;请输入完整&quot;</span><br><span class="line">            &#125;)</span><br><span class="line">        # 判断数据库的账号是否存在</span><br><span class="line">        user=User.objects.filter(name=name).first()</span><br><span class="line">        if user:</span><br><span class="line">            return Response(&#123;</span><br><span class="line">                &quot;code&quot;: 202,</span><br><span class="line">                &quot;message&quot;: &quot;账号已存在&quot;</span><br><span class="line">            &#125;)</span><br><span class="line">        else:</span><br><span class="line">        	#  否则添加到数据库</span><br><span class="line">            User.objects.create(name=name,password=password)</span><br><span class="line">            return Response(&#123;</span><br><span class="line">                &quot;code&quot;: 200,</span><br><span class="line">                &quot;message&quot;: &quot;注册成功&quot;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>微信小程序获取用户信息以及用户的openid</title>
    <url>/2019/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%88%B7%E7%9A%84openid/</url>
    <content><![CDATA[<h1 id="微信小程序获取用户信息以及用户的openid"><a href="#微信小程序获取用户信息以及用户的openid" class="headerlink" title="微信小程序获取用户信息以及用户的openid"></a>微信小程序获取用户信息以及用户的openid</h1><ul>
<li><p>在微信开发者工具新创建一个项目时，新项目的示例中已有如何获取用户基本信息的例子，此处不再赘述</p>
</li>
<li><p>重点是用户openid的获取</p>
<ul>
<li><p>首先，这里需要两个参数，这个小程序的appId，以及在微信公众平台生成的本小程序的appsecret码，这里需要先登录微信公众平台的小程序模块</p>
<p>（1）<img src="http://ww1.sinaimg.cn/large/006Z3bUvly1g96k9bwmdqj31em0ifdh5.jpg" alt="第一步.png"></p>
<p>（2）<img src="http://ww1.sinaimg.cn/large/006Z3bUvly1g96kasve3cj31420cdq3i.jpg" alt="第二部.png"></p>
<p>（3）</p>
<p><img src="http://ww1.sinaimg.cn/large/006Z3bUvly1g96kb4pf1tj30ny0czglx.jpg" alt="第三部.png"></p>
</li>
<li><p>之后再微信开发者工具中，对调用的方法进行编辑，这里要用到微信官网API中的wx.login函数</p>
<p><img src="http://ww1.sinaimg.cn/large/006Z3bUvly1g96kef8tbtj30cg0bm74f.jpg" alt="第五步.png"></p>
<p>① 首先自定义一个函数，如我上图定义的getOpenId，在函数中调用wx.login方法，这个方法不需要传递参数，直接可以得到返回值，所以下一步直接通过success获得返回值，这个返回值返回的有一部分是用户登录后的一个密钥，如果要获取用户的openid会用到</p>
<p>②在success中再次调用微信的一个方法wx.request，这个方法几乎等同于ajax和axios，传递的参数也是一样的，如图，将wx.login获取到的code值，小程序的appid和appsecret都作为参数传递到后台自己定义的接口中</p>
<p>③后台接口如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/006Z3bUvly1g96kvttho2j30rp0fa760.jpg" alt="第六步.png"></p>
<p>这里将这个url贴过来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url = r&quot;https://api.weixin.qq.com/sns/jscode2session?appid=%s&amp;secret=%s&amp;js_code=%s&amp;grant_type=authorization_code&quot; % (appid, secret, code)</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是要用到requests库来发送请求</p>
<p>④一切顺利的话返回的数据是这样的，也就是得到了用户的openid，而那个session_key则是用来判断用户登陆状态的，之后会另写一个文档介绍这个</p>
<p><img src="http://ww1.sinaimg.cn/large/006Z3bUvly1g96l8psu02j30hx0210sn.jpg" alt="第七部.png"></p>
<p>如果返回的不是这样的，那就是出问题了，原因可能有两种：</p>
<p>​    ⑴ wx.login返回的code值被多次调用了：</p>
<p>​        具体还不知道是哪里有问题，这样的报错可以自行百度</p>
<p>​    ⑵ appid或者appsecret有误：</p>
<p>​        这样的报错极有可能是在创建新项目的时候appid被替换了，需要给这个项目替换上微信公众平台上的appid，并重置一个appsecret再来试试</p>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>微信小程序代码规范</title>
    <url>/2019/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h5 id="微信小程序里的四种文件"><a href="#微信小程序里的四种文件" class="headerlink" title="微信小程序里的四种文件"></a>微信小程序里的四种文件</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.json</span> 后缀的 <span class="selector-tag">JSON</span> 配置文件</span><br><span class="line"><span class="selector-class">.wxml</span> 后缀的 <span class="selector-tag">WXML</span> 模板文件</span><br><span class="line"><span class="selector-class">.wxss</span> 后缀的 <span class="selector-tag">WXSS</span> 样式文件</span><br><span class="line"><span class="selector-class">.js</span> 后缀的 <span class="selector-tag">JS</span> 脚本逻辑文件</span><br></pre></td></tr></table></figure>

<h5 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">### 图片资源</span></span><br><span class="line">目前图片资源的主要性能问题在于大图片和长列表图片上，</span><br><span class="line">这两种情况都有可能导致 iOS 客户端内存占用上升，</span><br><span class="line">从而触发系统回收小程序页面。</span><br><span class="line"><span class="meta">### 图片对内存的影响</span></span><br><span class="line">在 iOS 上，小程序的页面是由多个 <span class="built_in">WKWebView</span> 组成的，</span><br><span class="line">在系统内存紧张时，会回收掉一部分 <span class="built_in">WKWebView</span>。</span><br><span class="line">从过去我们分析的案例来看，大图片和长列表图片的使用会引起 <span class="built_in">WKWebView</span> 的回收。</span><br><span class="line"><span class="meta">### 图片对页面切换的影响</span></span><br><span class="line">除了内存问题外，大图片也会造成页面切换的卡顿。</span><br><span class="line">我们分析过的案例中，有一部分小程序会在页面中引用大图片，</span><br><span class="line">在页面后退切换中会出现掉帧卡顿的情况。</span><br><span class="line">当前我们建议开发者尽量减少使用大图片资源。</span><br></pre></td></tr></table></figure>

<h5 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">所有资源文件(如图片)放在统一文件下及其子文件中(例如以下分类)</span><br><span class="line">resource</span><br><span class="line">  ——<span class="keyword">public</span></span><br><span class="line">  ——tab</span><br><span class="line">  ——home</span><br><span class="line">  ——mine</span><br></pre></td></tr></table></figure>

<h5 id="基础页面"><a href="#基础页面" class="headerlink" title="基础页面"></a>基础页面</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">业务展示的页面放在如 pages 文件及其子文件中(例如以下分类)</span><br><span class="line">pages</span><br><span class="line">  ——index</span><br><span class="line">  ——mall</span><br><span class="line">    ——goodList</span><br><span class="line">    ——goodDetail</span><br><span class="line">  ——order</span><br><span class="line">    ——orderList</span><br><span class="line">    ——orderDetail</span><br><span class="line">  ——mine</span><br><span class="line">    ——myInfo</span><br><span class="line">    ——myAddress</span><br><span class="line">    </span><br><span class="line">如有其他子业务，单独在pages里创建新的子级文件</span><br><span class="line">注释规范</span><br><span class="line">   针对wxml页面由上到下(或由左到右)分级的模块，均需注释出其功能，</span><br><span class="line">   并在其上下空出一行与其他代码进行区分。</span><br></pre></td></tr></table></figure>

<h5 id="样式文件"><a href="#样式文件" class="headerlink" title="样式文件"></a>样式文件</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">基础样式文件，在最外层中创建(如：<span class="selector-tag">weui</span><span class="selector-class">.wxss</span>)</span><br><span class="line">第一步：写入公共样式：如 </span><br><span class="line">1.标题字体大小，描述字体大小等项目中一二三级字号；</span><br><span class="line">2.程序中所用的公共色值；</span><br><span class="line">3.布局方式<span class="selector-tag">flex</span>的横向布局，纵向布局等；</span><br><span class="line">4.公共布局中<span class="selector-tag">wxss</span>样式前缀统一(如<span class="selector-tag">weui-</span>开头)；</span><br><span class="line">等等</span><br><span class="line"></span><br><span class="line">第二步：在<span class="selector-tag">app</span><span class="selector-class">.wxss</span>文件最上部，引入 @<span class="keyword">import</span> <span class="string">"weui.wxss"</span>;</span><br><span class="line">以上公共样式便可全局使用</span><br><span class="line"><span class="selector-tag">wxss</span>规范</span><br><span class="line">    1<span class="selector-class">.wxss</span> 页面可使用快捷键真理代码(<span class="selector-tag">Shift</span>+<span class="selector-tag">Alt</span>+<span class="selector-tag">F</span>)</span><br><span class="line">    整理后代码有明显的代码缩进，对齐。每一个样式类之间空出一行；</span><br><span class="line"></span><br><span class="line">    2.在开发过程中<span class="selector-tag">rpx</span>和<span class="selector-tag">px</span>均可能用到，</span><br><span class="line">    如通常情况下间距使用<span class="selector-tag">rpx</span>，</span><br><span class="line">    字体大小和边框等使用<span class="selector-tag">px</span>，开发者根据实际情况而定；</span><br><span class="line">       </span><br><span class="line">    3.同一块的样式属性(如 <span class="selector-class">.order-title</span> 和 <span class="selector-class">.order-image</span>)放在一块；</span><br><span class="line">    </span><br><span class="line">    4<span class="selector-class">.wxss</span> 样式中同一块可以这样抒写(如 <span class="selector-class">.order</span><span class="selector-class">.title</span>)</span><br><span class="line">    意思是<span class="selector-class">.order</span>样式下的<span class="selector-class">.title</span>,</span><br><span class="line">    其他地方的class='title'不会引用到.order下的.title</span><br><span class="line">    </span><br><span class="line">    5<span class="selector-class">.wxss</span>样式之间用块状注释。请勿在代码后面直接注释。</span><br></pre></td></tr></table></figure>

<h5 id="JS规范"><a href="#JS规范" class="headerlink" title="JS规范"></a>JS规范</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">JS规范</span><br><span class="line">    <span class="number">1.</span>删除js文件中未用到的生命周期函数，保持代码的整洁</span><br><span class="line">    <span class="number">2.</span>右上角不要分享的页面，删除JS文件中该方法onShareAppMessage:function()</span><br><span class="line">    <span class="number">3.</span>采用ES6 关键字<span class="keyword">let</span>定义变量，尽量不使用<span class="keyword">var</span></span><br><span class="line">    <span class="number">4.</span>所有涉及到数据绑定的变量均需在data中初始化,禁止在不定义的情况下直接setData</span><br><span class="line">    <span class="number">5.</span>变量名以及函数名统一采用驼峰命名法(或下划线分割)</span><br><span class="line">    <span class="number">6.</span>正常情况下函数名前缀需加上清晰的动词表示函数功能(如getOderList)</span><br><span class="line">    <span class="number">7.</span>点击事件函数命名方式为 <span class="keyword">on</span> + 事件名 或者业务名</span><br><span class="line">    <span class="number">8.</span>JS语句无需以分号结束，统一省略分号</span><br><span class="line">    <span class="number">9.</span>JS中一致使用单引号<span class="string">' '</span> , WXML中一致使用双引号<span class="string">" "</span></span><br></pre></td></tr></table></figure>



<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>一个ES6的模块是一个包含了js代码的文件。<strong>ES6里没有所谓的module关键字，一个模块就是一个普通的脚本文件</strong>，除了以下两个区别：</p>
<p>\1. ES6中的模块自动开启严格模式。<br>\2. 模块中可以使用import和export。</p>
<p><strong>导入和导出</strong></p>
<p>我们可以通过import和export关键字将函数或<strong>对象导入和导出模块</strong>。<br>先来说说export，在模块中声明的任何东西都是默认私有的，<strong>如果想对其他模块public，必须将那部分代码export</strong>。最简单的方法就是添加一个export关键字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`// kittydar.js`</span><span class="string">`export `</span><span class="string">`function`</span> <span class="string">`detectCats(canvas, options) &#123;`</span><span class="string">`var`</span> <span class="string">`kittydar = `</span><span class="string">`new`</span> <span class="string">`Kittydar(options);`</span><span class="string">`return`</span> <span class="string">`kittydar.detectCats(canvas);`</span><span class="string">`&#125;`</span><span class="string">`export class Kittydar &#123;`</span><span class="string">`... several methods doing image processing ...`</span><span class="string">`&#125;`</span><span class="string">`// This helper function isn't exported.`</span><span class="string">`function`</span> <span class="string">`resizeCanvas() &#123;`</span><span class="string">`...`</span><span class="string">`&#125;`</span><span class="string">`...`</span></span><br></pre></td></tr></table></figure>

<p>不再有跨文件或跨模块的全局变量，<strong>export声明的那部分就是这个模块的public API</strong>。而在另外一个文件中，我们可以导入这个模块并且使用detectCat方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`// demo.js - Kittydar demo program`</span><span class="string">`import &#123;detectCats&#125; from `</span><span class="string">`"kittydar.js"`</span><span class="string">`;`</span><span class="string">`function`</span> <span class="string">`go() &#123;`</span><span class="string">`var`</span> <span class="string">`canvas = document.getElementById(`</span><span class="string">`"catpix"`</span><span class="string">`);`</span><span class="string">`var`</span> <span class="string">`cats = detectCats(canvas);`</span><span class="string">`drawRectangles(canvas, cats);`</span><span class="string">`&#125;`</span></span><br></pre></td></tr></table></figure>

<p>如果需要导入多个模块中的接口，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`import &#123;detectCats, Kittydar&#125; from `</span><span class="string">`"kittydar.js"`</span><span class="string">`;`</span></span><br></pre></td></tr></table></figure>

<p>我们也可以通过一行代码将本模块所有需要public的方法公开：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`export &#123;detectCats, Kittydar&#125;;`</span></span><br></pre></td></tr></table></figure>

<p>这样就不用一个个地添加export关键字了。</p>
<p><strong>命名冲突</strong></p>
<p>上面介绍了模块中的导入和导出，那么如果导入的变量名和模块中的变量名冲突了应该如何是好呢？放心，<strong>ES6允许我们为导入的内容重命名</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`import &#123;flip as flipOmelet&#125; from `</span><span class="string">`"eggs.js"`</span><span class="string">`;`</span><span class="string">`import &#123;flip as flipHouse&#125; from `</span><span class="string">`"real-estate.js"`</span><span class="string">`;`</span></span><br></pre></td></tr></table></figure>

<p>这样就将从eggs模块来的<strong>flip改为了flipOmelet</strong>，从real-estate模块来的<strong>flip改为了flipHouse</strong>，从而避免了冲突。</p>
<p>同样的，我们也可以在模块导出变量名时进行重命名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`function`</span> <span class="string">`v1() &#123; ... &#125;`</span><span class="string">`function`</span> <span class="string">`v2() &#123; ... &#125;`</span><span class="string">`export &#123;`</span><span class="string">`v1 as streamV1,`</span><span class="string">`v2 as streamV2,`</span><span class="string">`v2 as streamLatestVersion`</span><span class="string">`&#125;;`</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>flask-socketio</title>
    <url>/2018/12/09/flask-socketio/</url>
    <content><![CDATA[<!-- vim-markdown-toc GFM -->

<ul>
<li><a href="#flask-socketio">flask-socketio</a><ul>
<li><a href="#installation安装">Installation(安装)</a></li>
<li><a href="#requirements依赖">Requirements(依赖)</a></li>
<li><a href="#initialization初始化">Initialization(初始化)</a></li>
<li><a href="#receiving-messages接收消息-">Receiving Messages(接收消息) ==</a></li>
<li><a href="#sending-messages发送消息">Sending Messages(发送消息)</a></li>
<li><a href="#broadcasting广播">Broadcasting(广播)</a></li>
<li><a href="#rooms房间">Rooms(房间)</a></li>
<li><a href="#connection-events连接事件">Connection Events(连接事件)</a></li>
<li><a href="#class-based-namespaces基于类的命名空间">Class-Based Namespaces(基于类的命名空间)</a></li>
<li><a href="#error-handling">Error Handling</a></li>
<li><a href="#access-to-flasks-context-globals访问flask的全局上下文">Access to Flask’s Context Globals(访问Flask的全局上下文)</a></li>
<li><a href="#authentication验证">Authentication(验证)</a></li>
<li><a href="#使用带有flask-socketio的flask-login">使用带有Flask-SocketIO的Flask-Login</a></li>
<li><a href="#deployment部署">Deployment(部署)</a><ul>
<li><a href="#using-nginx-as-a-websocket-reverse-proxy使用nginx作为websocket反向代理">Using nginx as a WebSocket Reverse Proxy(使用nginx作为WebSocket反向代理)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#todo">TODO</a><ul>
<li><a href="#using-multiple-workers使用多个工作者">Using Multiple Workers(使用多个工作者)</a></li>
<li><a href="#emitting-from-an-external-process">Emitting from an External Process</a></li>
</ul>
</li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- vim-markdown-toc -->


<h1 id="flask-socketio"><a href="#flask-socketio" class="headerlink" title="flask-socketio"></a>flask-socketio</h1><p><em>Flask-SocketIO</em> 给Flask应用提供了客户端和服务端低延时双向通信。客户端这边应用程序可以使用<br>Javascript，C++，Java，Swift的官方SocketIO库,或者兼容客户端向服务端建立一个持久链接的编程语言<br>中任意一个官方[[<a href="http://socket.io/|SocketIO]]库。" target="_blank" rel="noopener">http://socket.io/|SocketIO]]库。</a></p>
<h2 id="Installation-安装"><a href="#Installation-安装" class="headerlink" title="Installation(安装)"></a>Installation(安装)</h2><p><code>pip install flask-socketio</code></p>
<h2 id="Requirements-依赖"><a href="#Requirements-依赖" class="headerlink" title="Requirements(依赖)"></a>Requirements(依赖)</h2><p>Flask-SocketIO兼容python2.7和python3.3+。Flask-SocketIO包的异步服务依赖于以下三种选择:</p>
<ul>
<li><a href="http://eventlet.net/" target="_blank" rel="noopener">eventlet</a>是最好的选择,支持长轮询和WebSocket传输</li>
<li><a href="http://www.gevent.org/" target="_blank" rel="noopener">gevent</a>支持不同的配置。长轮询在gevent包里被完全支持,但是不像eventlet，gevent自己并不支持WebSocket。为了支持WebSocket当前有两个选择。安装<a href="https://pypi.python.org/pypi/gevent-websocket/" target="_blank" rel="noopener">gevent-websocket</a>包和使用<a href="https://uwsgi-docs.readthedocs.io/en/latest/" target="_blank" rel="noopener">uWSGI</a>web服务，uWSGI提供WebSocket功能。gevent也是一个不错的选择，但是略低于eventlet。</li>
<li>基于Werkzeug的Flask开发服务也可以用，但是给出警告，它的性能低于前两个选择，所以它应该被用于开发中。这个选项只支持长轮训传输。</li>
</ul>
<p>采用哪个异步框架取决于本机安装了什么。优先使用eventlet，gevent次之。对于gevent中支持WebScket， uWSGI优先，gevent-websocket次之。如果既没有eventlet也没有gevent安装，那么使用Flask开发服务。</p>
<p>如果使用多进程，消息队列服务将被用于协调操作，例如广播。支持的队列有<a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>,<a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>,和任意支持<a href="http://kombu.readthedocs.org/en/latest/" target="_blank" rel="noopener">Kombu</a>包的消息队列。</p>
<p>客户端这边，官方的Socket.IO Javascript客户端库可以用来和服务端建立连接。这里也有些用Swift，Java，C++写的官方客户端。非官方客户端可能也能工作，只要实现了<a href="https://github.com/socketio/socket.io-protocol" target="_blank" rel="noopener">Socket.IO协议</a></p>
<h2 id="Initialization-初始化"><a href="#Initialization-初始化" class="headerlink" title="Initialization(初始化)"></a>Initialization(初始化)</h2><p>下面代码例子展示了如何在Flask应用中添加Flask-SocketIO：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"><span class="keyword">from</span> flask_socketio imoprt SocketIO</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SECRET_KEY'</span>] = <span class="string">'secret!'</span></span><br><span class="line">socketio = SocketIO(app)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    socketio.run(app)</span><br></pre></td></tr></table></figure>
<p>init_app()风格的初始化也是被支持的。注意这种方式中web服务被启动了。socketio.run()方法封装了web服务的启动并且替代了app.run()来启动Flask开发服务。当应用在debug模式Werkzeug开发服务将被使用并且是在socketio.run()来配置属性。在生产模式如果eventlet有效，eventlet web服务将被使用，否则使用gevent的。如果eventlet和gevent都没安装，将使用Werkzeug开发web服务。</p>
<p>Flask 0.11引入的”flask运行命令”可以用来启动基于Werkzeug的Flask-SocketIO开发服务，但是这种方式启动由于缺少对WebSocket支持而被不推荐。这个包（flask-socket）的之前版本包含了“flask运行命令”，允许使用eventlet和gevent的WebSocket生产服务。但是这个功能已经在上面展示的socketio.run(app)中停止了。</p>
<p>这个应用只能服务于客户端页面。客户端加载了Socket.IO库和建立连接。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> socket = io.connect(<span class="string">'http://'</span> + <span class="built_in">document</span>.domain + <span class="string">':'</span> + location.port);</span><br><span class="line">    socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        socket.emit(<span class="string">'my event'</span>, &#123;<span class="attr">data</span>: <span class="string">'I\'m connected!'</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Receiving-Messages-接收消息"><a href="#Receiving-Messages-接收消息" class="headerlink" title="Receiving Messages(接收消息) =="></a>Receiving Messages(接收消息) ==</h2><p>当使用SocketIO，消息被事件的两端接收。客户端这边使用Javascript回调。使用Flask-SocketIO,服务端需要注册这些事件的处理，类似路由通过视图函数处理。</p>
<p>下面例子给一个无名事件创建服务端这边的事件处理函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    print(<span class="string">'received message: '</span> + message)</span><br></pre></td></tr></table></figure>
<p>上线例子使用字符消息。另一个无名事件使用JSON数据:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('json')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_json</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'received json:'</span> + str(json))</span><br></pre></td></tr></table></figure>
<p>最灵活的事件类型是自定义事件名称。这些事件的消息数据可以是string,bytes，int或者JSON:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'received json:'</span> _ str(json))</span><br></pre></td></tr></table></figure>
<p>自定义名称事件也支持多参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(args1, args2, args3)</span>:</span></span><br><span class="line">    print(<span class="string">'received args:'</span> + args1 + args2 + args3)</span><br></pre></td></tr></table></figure>
<p>命名事件是非常灵活的，因为它们不需要包括额外元数据来描述消息类型。<br>Flask-SocketIO也支持SocketIO命名空间，命名空间允许客户端通过多个不同独立连接在同一个物理socket上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event', namespace='/test')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_namespace_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'receviced json:'</span> + str(json))</span><br></pre></td></tr></table></figure>
<p>当命名空间没有指定，默认全局命名空间’/‘将被使用。<br>对于某些时候装饰器语法并不方便，on_event方法可以使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function_handler</span><span class="params">(darta)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">socketio.on_event(<span class="string">'my event'</span>, my_function_handler, namespace=<span class="string">'/test'</span>)</span><br></pre></td></tr></table></figure>
<p>客户端要求服务端回复一个确认收到客户端发来消息的应答,处理函数返回的任何值都将传给客户端作为回调函数的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'received json:'</span> + str(json))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'one'</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子，客户端回调函数携带两个参数进行调用，’one’和2。如果处理函数没有任何返回值，客户端回调函数将不携带任何参数进行调用。</p>
<h2 id="Sending-Messages-发送消息"><a href="#Sending-Messages-发送消息" class="headerlink" title="Sending Messages(发送消息)"></a>Sending Messages(发送消息)</h2><p>之前章节里定义的SocketIO事件处理函数可以通过send()和emit()函数发送回复消息给连接的客户端。</p>
<p>下面例子将收到的消息返回给发送过来的客户端：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> send, emit</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    send(message)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@socketio.on('json')    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_json</span><span class="params">(json)</span>:</span></span><br><span class="line">    send(json, json=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@socketio.on('my event')    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_envent</span><span class="params">(json)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, json)</span><br></pre></td></tr></table></figure>
<p>注意send()和emit()如何被用来分别给无名和命名事件发送消息的</p>
<p>当使用了命名空间，send()和emit()将默认使用发来消息的命名空间。可以通过指定可选参数namespace来给不同命名空间发送消息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    send(message, namespace=<span class="string">'/chat'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, json, namespace=<span class="string">'/chat'</span>)</span><br></pre></td></tr></table></figure>
<p>为了发送多个参数的事件，通过发送一个元组来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, (<span class="string">'foo'</span>, <span class="string">'bar'</span>, json), namespace=<span class="string">'/chat'</span>)</span><br></pre></td></tr></table></figure>
<p>使用回调时，Javascript客户端根据收到的消息来调用回调函数。客户端应用执行回调函数之后服务端调用相应的服务端回调。如果客户端的回调携带参数调用，这些参数也将作为服务端回调的参数</p>
<h2 id="Broadcasting-广播"><a href="#Broadcasting-广播" class="headerlink" title="Broadcasting(广播)"></a>Broadcasting(广播)</h2><p>另一个非常有用的SocketIO特性是消息广播。Flask-SocketIO通过send()和emit()中的可选参数broadcast=True来支持这个特性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(data)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, data, broadcast=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>当broadcast选项为True情况下发送消息，所有连接同个命名空间的客户端连接将收到这个消息，包括发送者。没有指定命名空间时，连接到全局命名空间的客户端将受到消息。注意广播消息不会调用回调函数。</p>
<p>上面所有例子都建立在服务端收到客户端的事件，但是有些应用服务端需要是消息的发起者。这对实现服务端发送通知给客户端很有用，比如在后台线程中。socketio.send()和socketio.emit()方法可以对所有连接的客户端广播：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_function</span><span class="params">()</span>:</span></span><br><span class="line">    socketio.emit(<span class="string">'some event'</span>, &#123;<span class="string">'data'</span>: <span class="number">42</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>注意在上下文感知上，socketio.send()和socketio.emit()是不一样的函数。也要注意上面没有客户端上下文的用法,所以broadcast=True是假定的并且不需要特指。</p>
<h2 id="Rooms-房间"><a href="#Rooms-房间" class="headerlink" title="Rooms(房间)"></a>Rooms(房间)</h2><p>对于很多应用对用户分组成子集并在子集中互相通信是必要的。很好的一个例子是多房间的聊天室，这里用户收到来自一个或多个他们进入的房间，但是不会收到另外房间的消息。Flask-SocketIO通过join_room()和leave_room()来支持房间概念:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> join_room, leave_room</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('join')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_join</span><span class="params">(data)</span>:</span></span><br><span class="line">    username = data[<span class="string">'username'</span>]</span><br><span class="line">    room = data[<span class="string">'room'</span>]</span><br><span class="line">    join_room(room)</span><br><span class="line">    send(username + <span class="string">' has entered the room.'</span>, room=room)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('leave')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_leave</span><span class="params">(data)</span>:</span></span><br><span class="line">    username = data[<span class="string">'username'</span>]</span><br><span class="line">    room = data[<span class="string">'room'</span>]</span><br><span class="line">    leave_room(room)</span><br><span class="line">    send(username + <span class="string">' has left the room.'</span>, room=room)</span><br></pre></td></tr></table></figure>
<p>send()和emit()函数接受可选参数room来控制消息发送给指定room的所有用户。</p>
<p>所有客户端在连接时赋值一个房间，名字使用连接的session ID，通过request.sid获得。客户端可以加入任何房间，房间可以起任何名称。当客户端断开连接，它将从进入过的房间移除。上下文无关socketio.send()和socketio.emit()函数也同样接受room参数来对一个房间进行广播</p>
<p>由于所有客户端分配到个人房间，给单个客户端发消息，客户端的session ID可以用来做room参数</p>
<h2 id="Connection-Events-连接事件"><a href="#Connection-Events-连接事件" class="headerlink" title="Connection Events(连接事件)"></a>Connection Events(连接事件)</h2><p>Flask-SocketIO也派遣连接和断开连接事件。下面例子展示如何为它们注册处理函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('connect', namespace='/chat')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_connect</span><span class="params">()</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, &#123;<span class="string">'data'</span>: <span class="string">'Connected'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('disconnect', namespace='/chat')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_disconnect</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Client disconnected'</span>)</span><br></pre></td></tr></table></figure>
<p>connection事件处理函数可以返回False来拒绝连接，这里便于客户端在这里权限校验<br>注意connection和disconnection事件在每个命名空间独立发送</p>
<h2 id="Class-Based-Namespaces-基于类的命名空间"><a href="#Class-Based-Namespaces-基于类的命名空间" class="headerlink" title="Class-Based Namespaces(基于类的命名空间)"></a>Class-Based Namespaces(基于类的命名空间)</h2><p>一种是上面描述的基于装饰器的事件处理，另一种方式是创建类方法作为事件处理。flask_socketio.Namespace作为基类来创建一个基于类的命名空间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> Namespace, emit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomNamespace</span><span class="params">(Namespace)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_disconnect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_my_event</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        emit(<span class="string">'my_response'</span>, data)</span><br><span class="line">socketio.on_namespace(MyCustomNamespace(<span class="string">'/test'</span>))</span><br></pre></td></tr></table></figure>
<p>当基于类的命名空间被启用，任何被服务端收到的事件将派遣到方法名是以事件名加on_为前缀的方法中。举个例子，事件my_event将被方法名为on_my_event处理。如果收到一个事件在类命名空间中没有对应的方法，那么事件将被忽略。所有使用命名空间类的事件名必须使用方法名合法的字符。</p>
<blockquote>
<p>[原文]As a convenience to methods defined in a class-based namespace, the namespace instance includes versions of several of the methods in the flask_socketio.SocketIO class that default to the proper namespace when the namespace argument is not given.</p>
</blockquote>
<p>如果一个事件即有命名空间类的处理方法也有装饰器处理函数，那么只有装饰器处理函数被调用。</p>
<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><p>Flask-SocketIO也可以处理异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on_error()        # Handles the default namespace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_handler</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on_error('/chat') # handles the '/chat' namespace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_handler_chat</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on_error_default  # handles all namespaces without an explicit error handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_error_handler</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>错误处理函数将异常对象作为一个参数</p>
<p>当前请求的消息和数据参数可以通过request.event变量来检查，这有利于外部活动处理函数的错误日志和调试:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on("my error event")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_my_event</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> RuntimeError()</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on_error_default</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_error_handler</span><span class="params">(e)</span>:</span></span><br><span class="line">    print(request.event[<span class="string">"message"</span>]) <span class="comment"># "my error event"</span></span><br><span class="line">    print(request.event[<span class="string">"args"</span>])    <span class="comment"># (data,)</span></span><br></pre></td></tr></table></figure>

<h2 id="Access-to-Flask’s-Context-Globals-访问Flask的全局上下文"><a href="#Access-to-Flask’s-Context-Globals-访问Flask的全局上下文" class="headerlink" title="Access to Flask’s Context Globals(访问Flask的全局上下文)"></a>Access to Flask’s Context Globals(访问Flask的全局上下文)</h2><p>SocketIO事件处理函数不同于路由处理函数，这里介绍SocketIO处理函数中在哪些能做哪些不能做中容易混淆的东西。最主要的不同是所有SocketIO事件发生在单个长期运行的上下文请求之中。</p>
<p>尽管不同，但Flask-SocketIO尝试使SocketIO事件处理和常规HTTP请求的环境相似。下面描述了哪些还能正常工作，哪些不能了：</p>
<ul>
<li>在事件处理函数之前,应用上下文被压入（保存在数据结构中）使得current_app和g可以在处理函数中可用。</li>
<li>在调用处理函数之前请求上下文也被压入，同样使得request和session可用。但是注意WebSocket事件没有与之相关联的请求，所以对于在存活的连接中所有被派遣的事件请求上下文是在开始连接的时候被压入。</li>
<li>请求上下文(全局变量request)被连接产生的唯一session ID设置的sid变量所增强(request全局变量里增加了sid,http请求中是没有sid的)。这个值被用来初始化客户端加入的房间(room)。</li>
<li>请求上下文被含有命名空间和事件参数的namespace和event成员所增强(request中增加了namespace和event变量)。event成员是一个含有message和args的字典。</li>
<li>全局上下文变量<code>session</code>行为和常规的请求不一样。在SocketIO建立使处理函数在连接上下文中被调用的时候用户session被拷贝了一份。如果SocketIO处理函数修改了session，被修改的session变量将会被后续SocketIO处理函数有效，但是常规HTTP路由的处理函数看不到修改的变化。实际上，当SocketIO处理函数修改session，session的副本将被创建用于这些处理函数。这种限制的技术原因是，为了保存用户会话，需要将cookie发送到客户机，这需要HTTP请求和响应，而SocketIO连接中不存在这样的请求和响应。当使用诸如Flask-Session或Flask-KVSession扩展提供的服务器端会话时，只要会话没有在SocketIO处理程序中修改，SocketIO处理程序就可以看到HTTP路由处理程序中对会话所做的更改。</li>
<li>before_request和after_request钩子在SocketIO事件处理中无效。</li>
<li>SocketIO处理函数可以使用自定义的装饰器，但是许多Flask装饰器不能用在SocketIO处理函数上，在SocketIO连接中没有响应对象这个概念。</li>
</ul>
<h2 id="Authentication-验证"><a href="#Authentication-验证" class="headerlink" title="Authentication(验证)"></a>Authentication(验证)</h2><p>应用的共同需要就是验证他们用户的身份。自从SocketIO没有使用HTTP请求和应答，传统的基于网页表单和HTTP请求的机制不能用于SocketIO连接。如果需要的话，应用可以实施自定义的登陆表单，当用户按下提交按钮时，它利用一个SocketIO消息将证书发送到服务器。</p>
<p>然而，在大多数情况下，在SocketIO连接建立之前使用传统的身份验证方式会更加方便，用户的身份信息可以被记录下来作为用户会话或者cookie，之后在SocketIO连接建立起来的时候，这些信息也可以被SocketIO活动处理器得到。</p>
<h2 id="使用带有Flask-SocketIO的Flask-Login"><a href="#使用带有Flask-SocketIO的Flask-Login" class="headerlink" title="使用带有Flask-SocketIO的Flask-Login"></a>使用带有Flask-SocketIO的Flask-Login</h2><p>Flask-SocketIO可以访问被<a href="https://flask-login.readthedocs.org/en/latest/" target="_blank" rel="noopener">Flask-Login</a>维护的登录信息。Flask-Login鉴定执行和<code>login_user()</code>函数调用来在用户session中记录用户后，任何SocketIO连接将可以访问<code>current_user</code>上下文比变量:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on('connect')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect_handler</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> current_user.is_authenticated:</span><br><span class="line">        emit(<span class="string">'my response'</span>,</span><br><span class="line">             &#123;<span class="string">'message'</span>: <span class="string">'&#123;0&#125; has joined'</span>.format(current_user.name)&#125;,</span><br><span class="line">             broadcast=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># not allowed here</span></span><br></pre></td></tr></table></figure>

<p>注意<code>login_required</code>装饰器不能用于SocketIO事件处理器,但是自定义一个无权限断开连接的装饰器如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> flask_login <span class="keyword">import</span> current_user</span><br><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> disconnect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticated_only</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> current_user.is_authenticated:</span><br><span class="line">            disconnect()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="meta">@authenticated_only</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(data)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, &#123;<span class="string">'message'</span>: <span class="string">'&#123;0&#125; has joined'</span>.format(current_user.name)&#125;,</span><br><span class="line">         broadcast=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Deployment-部署"><a href="#Deployment-部署" class="headerlink" title="Deployment(部署)"></a>Deployment(部署)</h2><h3 id="Using-nginx-as-a-WebSocket-Reverse-Proxy-使用nginx作为WebSocket反向代理"><a href="#Using-nginx-as-a-WebSocket-Reverse-Proxy-使用nginx作为WebSocket反向代理" class="headerlink" title="Using nginx as a WebSocket Reverse Proxy(使用nginx作为WebSocket反向代理)"></a>Using nginx as a WebSocket Reverse Proxy(使用nginx作为WebSocket反向代理)</h3><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><h2 id="Using-Multiple-Workers-使用多个工作者"><a href="#Using-Multiple-Workers-使用多个工作者" class="headerlink" title="Using Multiple Workers(使用多个工作者)"></a>Using Multiple Workers(使用多个工作者)</h2><p>Flask-SocketIO从2.0版本开始在负载均衡器后面支持多个Worker(工作者).部署多个worker给Flask-SocketIO应用有能力在多个进程和主机上传播客户端连接,也因此可以支持更多的客户端并发。</p>
<p>使用多工作者模式需要两个依赖:</p>
<ul>
<li>负载均衡器必须被配置成从一个客户端来的所有HTTP请求发送到同一个worker处理。这个有时被称为”sticky sessions”。对于nginx，用ip_hash直接实现会话保持。Gunicorn不能被用于多个工作者，因为它的负载均衡算法不支持粘滞会话(sticky sessions)。</li>
<li>因为每一个server只拥有客户端连接的子集，所以例如Redis或者RabbitMQ这样的消息队列被用来协同一些操作，例如broadcasting(广播)和rooms。（译者注：这个应该好理解，多个worker部署在不同机器上，就有可能一个room的连接分布在不同机器上，如果要对房间内得人进行广播，那么必然要有个介质用来协调）。</li>
</ul>
<p>当在消息队列下工作就需要安装下面这些依赖:</p>
<ul>
<li>对于Redis，redis包必须安装(pip install redis).</li>
<li>对于RabbitMQ,kombu包必须安装(pip install kombu)</li>
<li>对于其它支持Kombu的消息队列，查看<a href="http://docs.celeryproject.org/projects/kombu/en/latest/introduction.html#transport-comparison" target="_blank" rel="noopener">Kombu documentation</a>来确定依赖什么</li>
<li>如果消息队列用到eventlet或者gevent,那么通常也需要python标准库的猴子补丁来让消息队列包工作</li>
</ul>
<p>为了让Flask-SocketIO服务器们跑起来，你必须首先确保有个消息队列跑起来。为了让Socket.IO服务器跑起来并且连接上消息队列，需要SocketIO构造器中增加一个message_queue参数：<br><code>socketio = SocketIO(app, message_queue=&#39;redis://&#39;)</code><br>message_queue参数值是你使用的消息队列URL连接。如果redis消息队列和服务跑在同一个主机上，可以使用’redis://‘URL。同样的，RabbitMQ队列使用’amqp://‘。Kombu包里的<a href="http://docs.celeryproject.org/projects/kombu/en/latest/userguide/connections.html?highlight=urls#urls" target="_blank" rel="noopener">文档</a>有描述它支持的队列URL格式。</p>
<h2 id="Emitting-from-an-External-Process"><a href="#Emitting-from-an-External-Process" class="headerlink" title="Emitting from an External Process"></a>Emitting from an External Process</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[[<a href="https://www.jianshu.com/p/d81397edd2b1]]" target="_blank" rel="noopener">https://www.jianshu.com/p/d81397edd2b1]]</a></p>
<p>[[<a href="https://flask-socketio.readthedocs.io/en/latest/]]" target="_blank" rel="noopener">https://flask-socketio.readthedocs.io/en/latest/]]</a></p>
]]></content>
  </entry>
  <entry>
    <title>CentOS 7 安装 python3 v1.1</title>
    <url>/2018/11/19/CentOS%207%20%E5%AE%89%E8%A3%85%20python3%20v1.1/</url>
    <content><![CDATA[<h2 id="CentOS-7-安装-python3"><a href="#CentOS-7-安装-python3" class="headerlink" title="CentOS 7 安装 python3"></a>CentOS 7 安装 python3</h2><blockquote>
<p>CentOS 7 自带的python为python2.7版本，yum等包依赖于python2，不可以直接卸载。需要下载python3的源码后自行编译安装。以下是安装步骤</p>
</blockquote>
<h4 id="1-安装用于编译python源码的依赖包"><a href="#1-安装用于编译python源码的依赖包" class="headerlink" title="1. 安装用于编译python源码的依赖包"></a>1. 安装用于编译python源码的依赖包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc* make -y</span><br></pre></td></tr></table></figure>



<h4 id="2-安装下载源码的工具"><a href="#2-安装下载源码的工具" class="headerlink" title="2. 安装下载源码的工具"></a>2. 安装下载源码的工具</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install wget</span><br><span class="line"><span class="meta">#</span><span class="bash"> 由于还没有python3，这里的wget是安装到了python2.7中</span></span><br></pre></td></tr></table></figure>



<h4 id="3-下载python源码"><a href="#3-下载python源码" class="headerlink" title="3. 下载python源码"></a>3. 下载python源码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.7.5/Python-3.7.5.tar.xz</span><br></pre></td></tr></table></figure>



<h4 id="4-编译"><a href="#4-编译" class="headerlink" title="4. 编译"></a>4. 编译</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -xvJf Python-3.7.5.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入解压后的目录，配置安装路径</span></span><br><span class="line">./configure prefix=/usr/local/python3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译安装</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>



<h4 id="5-添加软链接"><a href="#5-添加软链接" class="headerlink" title="5. 添加软链接"></a>5. 添加软链接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加python3的软链接</span></span><br><span class="line">ln -s /usr/local/python3/bin/python3 /usr/bin/python3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加pip3的软连接</span></span><br><span class="line">ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">测试是否安装成功了</span></span><br><span class="line">python3 -V</span><br></pre></td></tr></table></figure>




<blockquote>
<p>python指向的是python2，python2指向的是python2.7，在装完python3后，将python指向python3，然后python2指向python2.7，那么两个版本的python就能共存了</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /usr/bin/yum</span><br><span class="line">把#! /usr/bin/python修改为#! /usr/bin/python2</span><br><span class="line"></span><br><span class="line">vi /usr/libexec/urlgrabber-ext-down</span><br><span class="line">把#! /usr/bin/python 修改为#! /usr/bin/python2</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>supervisor介绍</title>
    <url>/2018/05/26/supervisor%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="supervisor介绍"><a href="#supervisor介绍" class="headerlink" title="supervisor介绍"></a>supervisor介绍</h1><h2 id="一、supervisor简介"><a href="#一、supervisor简介" class="headerlink" title="一、supervisor简介"></a>一、supervisor简介</h2><p>Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。</p>
<h2 id="二、supervisor安装"><a href="#二、supervisor安装" class="headerlink" title="二、supervisor安装"></a>二、supervisor安装</h2><ol>
<li><p>配置好yum源后，可以直接安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install supervisor</span><br></pre></td></tr></table></figure>
</li>
<li><p>Debian/Ubuntu可通过apt安装</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">apt-<span class="keyword">get</span> install supervisor</span><br></pre></td></tr></table></figure>
</li>
<li><p>pip安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure>
</li>
<li><p>easy_install安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">easy_install supervisor</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="三、supervisor使用"><a href="#三、supervisor使用" class="headerlink" title="三、supervisor使用"></a>三、supervisor使用</h2><h5 id="supervisor配置文件：-etc-supervisord-conf"><a href="#supervisor配置文件：-etc-supervisord-conf" class="headerlink" title="supervisor配置文件：/etc/supervisord.conf"></a>supervisor配置文件：<code>/etc/supervisord.conf</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*注：supervisor的配置文件默认是不全的，不过在大部分默认的情况下，上面说的基本功能已经满足。*</span><br></pre></td></tr></table></figure>

<h5 id="子进程配置文件路径：-etc-supervisord-d"><a href="#子进程配置文件路径：-etc-supervisord-d" class="headerlink" title="子进程配置文件路径：/etc/supervisord.d/"></a>子进程配置文件路径：<code>/etc/supervisord.d/</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*注：默认子进程配置文件为ini格式，可在supervisor主配置文件中修改。*</span><br></pre></td></tr></table></figure>

<h2 id="四、配置文件说明"><a href="#四、配置文件说明" class="headerlink" title="四、配置文件说明"></a>四、配置文件说明</h2><h4 id="supervisor-conf配置文件说明："><a href="#supervisor-conf配置文件说明：" class="headerlink" title="supervisor.conf配置文件说明："></a>supervisor.conf配置文件说明：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=<span class="number">0700</span>                 ;socket文件的mode，默认是<span class="number">0700</span></span><br><span class="line">;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid</span><br><span class="line"> </span><br><span class="line">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span><br><span class="line">;port=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9001</span>        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username=user              ;登录管理后台的用户名</span><br><span class="line">;password=<span class="number">123</span>               ;登录管理后台的密码</span><br><span class="line"> </span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.<span class="built_in">log</span> ;日志文件，默认是 $CWD/supervisord.<span class="built_in">log</span></span><br><span class="line">logfile_maxbytes=<span class="number">50</span>MB        ;日志文件大小，超出会rotate，默认 <span class="number">50</span>MB，如果设成<span class="number">0</span>，表示不限制大小</span><br><span class="line">logfile_backups=<span class="number">10</span>           ;日志文件保留备份数量默认<span class="number">10</span>，设为<span class="number">0</span>表示不备份</span><br><span class="line">loglevel=info                ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ;pid 文件</span><br><span class="line">nodaemon=<span class="literal">false</span>               ;是否在前台启动，默认是<span class="literal">false</span>，即以 daemon 的方式启动</span><br><span class="line">minfds=<span class="number">1024</span>                  ;可以打开的文件描述符的最小值，默认 <span class="number">1024</span></span><br><span class="line">minprocs=<span class="number">200</span>                 ;可以打开的进程数的最小值，默认 <span class="number">200</span></span><br><span class="line"> </span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:<span class="comment">///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span></span><br><span class="line">;serverurl=http:<span class="comment">//127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span></span><br><span class="line"> </span><br><span class="line">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span><br><span class="line">[program:xx]</span><br><span class="line">command=/opt/apache-tomcat<span class="number">-8.0</span><span class="number">.35</span>/bin/catalina.sh run  ; 程序启动命令</span><br><span class="line">autostart=<span class="literal">true</span>       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs=<span class="number">10</span>         ; 启动<span class="number">10</span>秒后没有异常退出，就表示进程正常启动了，默认为<span class="number">1</span>秒</span><br><span class="line">autorestart=<span class="literal">true</span>     ; 程序退出后自动重启,可选值：[unexpected,<span class="literal">true</span>,<span class="literal">false</span>]，默认为unexpected，表示进程意外杀死后才重启</span><br><span class="line">startretries=<span class="number">3</span>       ; 启动失败自动重试次数，默认是<span class="number">3</span></span><br><span class="line">user=tomcat          ; 用哪个用户启动进程，默认是root</span><br><span class="line">priority=<span class="number">999</span>         ; 进程启动优先级，默认<span class="number">999</span>，值小的优先启动</span><br><span class="line">redirect_stderr=<span class="literal">true</span> ; 把<span class="built_in">stderr</span>重定向到<span class="built_in">stdout</span>，默认<span class="literal">false</span></span><br><span class="line">stdout_logfile_maxbytes=<span class="number">20</span>MB  ; <span class="built_in">stdout</span> 日志文件大小，默认<span class="number">50</span>MB</span><br><span class="line">stdout_logfile_backups = <span class="number">20</span>   ; <span class="built_in">stdout</span> 日志文件备份数，默认是<span class="number">10</span></span><br><span class="line">; <span class="built_in">stdout</span> 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile=/opt/apache-tomcat<span class="number">-8.0</span><span class="number">.35</span>/logs/catalina.out</span><br><span class="line">stopasgroup=<span class="literal">false</span>     ;默认为<span class="literal">false</span>,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span><br><span class="line">killasgroup=<span class="literal">false</span>     ;默认为<span class="literal">false</span>，向进程组发送kill信号，包括子进程</span><br><span class="line"> </span><br><span class="line">;包含其它配置文件</span><br><span class="line">[include]</span><br><span class="line">files = relative/directory<span class="comment">/*.ini    ;可以指定一个或多个以.ini结束的配置文件</span></span><br></pre></td></tr></table></figure>

<h4 id="子进程配置文件说明："><a href="#子进程配置文件说明：" class="headerlink" title="子进程配置文件说明："></a>子进程配置文件说明：</h4><p>给需要管理的子进程(程序)编写一个配置文件，放在<code>/etc/supervisor.d/</code>目录下，以<code>.ini</code>作为扩展名（每个进程的配置文件都可以单独分拆也可以把相关的脚本放一起）。如任意定义一个和脚本相关的项目名称的选项组（/etc/supervisord.d/test.conf）：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#项目名</span></span><br><span class="line">[<span class="symbol">program:</span>blog]</span><br><span class="line"><span class="comment">#脚本目录</span></span><br><span class="line">directory=<span class="regexp">/opt/bin</span></span><br><span class="line"><span class="comment">#脚本执行命令</span></span><br><span class="line">command=<span class="regexp">/usr/bin</span><span class="regexp">/python /opt</span><span class="regexp">/bin/test</span>.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#supervisor启动的时候是否随着同时启动，默认True</span></span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line"><span class="comment">#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的</span></span><br><span class="line">autorestart=<span class="literal">false</span></span><br><span class="line"><span class="comment">#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1</span></span><br><span class="line">startsecs=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本运行的用户身份 </span></span><br><span class="line">user = test</span><br><span class="line"></span><br><span class="line"><span class="comment">#日志输出 </span></span><br><span class="line">stderr_logfile=<span class="regexp">/tmp/blog</span>_stderr.log </span><br><span class="line">stdout_logfile=<span class="regexp">/tmp/blog</span>_stdout.log </span><br><span class="line"><span class="comment">#把stderr重定向到stdout，默认 false</span></span><br><span class="line">redirect_stderr = <span class="literal">true</span></span><br><span class="line"><span class="comment">#stdout日志文件大小，默认 50MB</span></span><br><span class="line">stdout_logfile_maxbytes = <span class="number">20</span>M</span><br><span class="line"><span class="comment">#stdout日志文件备份数</span></span><br><span class="line">stdout_logfile_backups = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h5 id="子进程配置示例："><a href="#子进程配置示例：" class="headerlink" title="子进程配置示例："></a>子进程配置示例：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#说明同上</span></span><br><span class="line">[program:<span class="built_in">test</span>] </span><br><span class="line">directory=/opt/bin </span><br><span class="line"><span class="built_in">command</span>=/opt/bin/<span class="built_in">test</span></span><br><span class="line">autostart=<span class="literal">true</span> </span><br><span class="line">autorestart=<span class="literal">false</span> </span><br><span class="line">stderr_logfile=/tmp/test_stderr.log </span><br><span class="line">stdout_logfile=/tmp/test_stdout.log </span><br><span class="line"><span class="comment">#user = test</span></span><br></pre></td></tr></table></figure>



<h2 id="五、supervisor命令说明"><a href="#五、supervisor命令说明" class="headerlink" title="五、supervisor命令说明"></a>五、supervisor命令说明</h2><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">supervisorctl status        <span class="comment">//查看所有进程的状态</span></span><br><span class="line">supervisorctl stop es       <span class="comment">//停止es</span></span><br><span class="line">supervisorctl start es      <span class="comment">//启动es</span></span><br><span class="line">supervisorctl restart       <span class="comment">//重启es</span></span><br><span class="line">supervisorctl update        <span class="comment">//配置文件修改后使用该命令加载新的配置</span></span><br><span class="line">supervisorctl reload        <span class="comment">//重新启动配置中的所有程序</span></span><br></pre></td></tr></table></figure>

<p>注：把<code>es</code>换成<code>all</code>可以管理配置中的所有进程。直接输入<code>supervisorctl</code>进入supervisorctl的shell交互界面，此时上面的命令不带supervisorctl可直接使用。</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>使用supervisor进程管理命令之前先启动supervisord，否则程序报错。<br> 使用命令<code>supervisord -c /etc/supervisord.conf</code>启动。<br> 若是centos7：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">systemctl start supervisord.service     <span class="comment">//启动supervisor并加载默认配置文件</span></span><br><span class="line">systemctl enable supervisord.service    <span class="comment">//将supervisor加入开机启动项</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>选择在Linux下安装redis</title>
    <url>/2018/04/19/%E9%80%89%E6%8B%A9%E5%9C%A8Linux%E4%B8%8B%E5%AE%89%E8%A3%85redis/</url>
    <content><![CDATA[<p>选择在Linux下安装redis，</p>
<p>1.安装gcc  redis是c语言编写的</p>
<pre><code>yum install gcc-c++</code></pre><p>2.下载redis安装包,在root目录下执行</p>
<pre><code>wget http://download.redis.io/releases/redis-5.0.4.tar.gz</code></pre><p>3.解压redis安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-5.0.4.tar.gz</span><br></pre></td></tr></table></figure>

<p>4.进入redis目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd redis-5.0.4</span><br></pre></td></tr></table></figure>

<p>5.编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>6.安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make PREFIX=/usr/local/redis install</span><br></pre></td></tr></table></figure>

<p>7.拷贝redis.conf到安装目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp redis.conf /usr/local/redis</span><br></pre></td></tr></table></figure>

<p>8.进入 /usr/local/redis目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/redis/</span><br></pre></td></tr></table></figure>

<p>9.编辑redis.conf   </p>
<pre><code>vim redis.conf

1.后台启动，daemonize yes

2.绑定端口，port 6379 默认是6379 需要安全组开放端口

3.绑定IP，bind 127.0.0.1:默认的

4.指定数据存放路径，dir /usr/local/redis/log存放的路径

5.指定持久化方式，appendonly yes

6.requirepass redis129 设置密码</code></pre><p> 10.后端启动redis：</p>
<pre><code>./bin/redis-server ./redis.conf</code></pre><p>11.查看是否启动成功：</p>
<pre><code>ps aux | grep redis</code></pre><p>12.杀死redis并重新启动redis:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkill -9 redis-server</span><br><span class="line">./bin/redis-server ./redis.conf</span><br></pre></td></tr></table></figure>

<p>13.检测是否开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps axu | grep redis-server</span><br></pre></td></tr></table></figure>

<p>14.客户端远程通过ip连接redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>

<p>如果出现如下，就是代表连接成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>使用Hexo搭建自己的个人博客</title>
    <url>/2018/04/19/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="使用Hexo搭建自己的个人博客"><a href="#使用Hexo搭建自己的个人博客" class="headerlink" title="使用Hexo搭建自己的个人博客"></a>使用Hexo搭建自己的个人博客</h1><h2 id="从零开始搭建自己的静态博客"><a href="#从零开始搭建自己的静态博客" class="headerlink" title="从零开始搭建自己的静态博客"></a>从零开始搭建自己的静态博客</h2><h2 id="前提摘要"><a href="#前提摘要" class="headerlink" title="前提摘要"></a>前提摘要</h2><ol>
<li><p>可能不需要会写多少代码，会照葫芦画瓢对一些地方进行修改就好。</p>
</li>
<li><p>安装node.js npm 了解基础知识 个人觉得不了解好像也没什么问题，跟着装就好了。然后就了解了啊。</p>
</li>
<li><p>安装git 可以不知道git是什么 hexo配合github搭建博客会用到四个常用的命令 到时候掌握了这四个命令的作用就行了</p>
</li>
<li><p>有一个github账号 和其他账号的注册没有什么区别。用github作为服务器使用。</p>
<ul>
<li>注册地址：<a href="https://github.com/" target="_blank" rel="noopener" github地址"">github地址</a> </li>
</ul>
</li>
<li><p>会markdown就好，不会也没关系，现学也可以很快掌握。</p>
<ul>
<li>推荐markdown编辑器：<strong>typora</strong></li>
</ul>
</li>
</ol>
<h3 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h3><h4 id="1-1-安装node-js"><a href="#1-1-安装node-js" class="headerlink" title="1.1 安装node.js"></a>1.1 安装node.js</h4><p>下载地址如下：<a href="http://nodejs.cn/download/,' target=" _blank" rel="noopener" node.js下载地址'">node.js下载</a></p>
<p>下载自己所需要的版本，与安装普通软件没有任何区别。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-e801cad5c7ac29dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>安装node.js</p>
<p>检查一下是否安装成功</p>
<p>windows系统下快捷键win+r 输入cmd</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-fb00e279ad960100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/646/format/webp" alt="img"></p>
<p>打开终端</p>
<p>在终端输入 npm -v 显示版本号则为安装成功 版本号不用和我的一样</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-fd4c2c6f6d8482ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/852/format/webp" alt="img"></p>
<h4 id="1-2-安装git"><a href="#1-2-安装git" class="headerlink" title="1.2 安装git"></a>1.2 安装git</h4><p>下载地址及安装方法如下：<a href="https://git-scm.com/book/zh/v1/起步-安装-Git" target="_blank" rel="noopener">git安装</a> 安装地址和方法这里都有说了</p>
<p>git安装 过程 <a href="https://blog.csdn.net/qq_41782425/article/details/85183250" target="_blank" rel="noopener">https://blog.csdn.net/qq_41782425/article/details/85183250</a></p>
<p>若是安装成功 鼠标右键会出现这俩图表</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-9b846e0c0d9a36cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/266/format/webp" alt="img"></p>
<p>git安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这两个是必备的工具 一定要安装上才行</span><br></pre></td></tr></table></figure>

<h3 id="二、创建库"><a href="#二、创建库" class="headerlink" title="二、创建库"></a>二、创建库</h3><h4 id="2-1注册gitbub账号"><a href="#2-1注册gitbub账号" class="headerlink" title="2.1注册gitbub账号"></a>2.1注册gitbub账号</h4><p>本来不想从注册开始写的…然后想了想不能做一个标题党，所以真的从零开始哦。</p>
<p><strong>① 输入地址 点击注册</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-ad94a5bfcd8e08ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>github注册地址</p>
<p><strong>② 填写表单</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-660b8360cc189692.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>填写表单</p>
<p><strong>③ 继续 账号也就有了</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-8ff40dc12c6fe5ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>注册</p>
<h4 id="2-2-建立仓库"><a href="#2-2-建立仓库" class="headerlink" title="2.2 建立仓库"></a>2.2 建立仓库</h4><p><strong>① 新建项目</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-41d7fb68fec46d06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>新建项目</p>
<p><strong>② 上邮箱里验证一下</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-4f4802e0b3cf5cc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>验证</p>
<p><strong>③新建项目</strong></p>
<p>新建一个名为<code>你的用户名.github.io</code>的仓库，例如，你的github用户名为user，就新建一个名为<code>user.github.io</code>的仓库（强制要求哦），将来你的网站访问地址就为：<a href="http://user.github.io/" target="_blank" rel="noopener">http://user.github.io</a> 并且一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 </p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-93f26bbcd60d6d53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>项目命名</p>
<h4 id="2-4-配置SSH-KEY"><a href="#2-4-配置SSH-KEY" class="headerlink" title="2.4 配置SSH KEY"></a>2.4 配置SSH KEY</h4><p>我们到时候会把本地的代码提交到github上，这一步就是配置权限，解决本地和服务器的链接问题</p>
<p><strong>① 鼠标右键git bash here</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-08490aec3bed2a3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/267/format/webp" alt="img"></p>
<p>配置步骤1</p>
<p><strong>②打开git bash，就是一个linux命令窗口</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-4c4695a3381570a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>配置步骤2</p>
<p><strong>③创建SSH keys</strong></p>
<blockquote>
<p>在bash中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;shaoshanhuan@163.com&quot;</span><br></pre></td></tr></table></figure>

<p>然后无脑回车~</p>
</blockquote>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-89919b214d8343e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>配置成功</p>
<p><strong>④复制keys</strong></p>
<p>进入生成的ssh目录 : C:\users(中文是用户)\你电脑的用户名 .ssh 中, 使用记事本打开 id_rsa.pub 文件, 将该文件中的内容复制</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-51cf57860d9e1613.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>复制keys</p>
<p><strong>⑤复制id_rsa.pub里面的内容</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-9218ee6a3b2bd82b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1198/format/webp" alt="img"></p>
<p>id_rsa.pub</p>
<p><strong>⑥将复制的内容粘进github</strong></p>
<p>有些网页看不懂可以全页翻译</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-31872c2efd264fb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>配置1</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-157568471846db81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>配置2</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-9ddd7f5b656f9f9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>配置3</p>
<p>前面加 $ 的都是在 git bash 里面 运行的，不要把 黑窗口和 git bash 搞混淆了</p>
<p><strong>⑦测试是否成功</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p>
<blockquote>
<p>Hi ***! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
<p>看到这个信息说明SSH已配置成功！</p>
<p>此时你还需要配置：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"***"</span><span class="comment">// 你的github用户名，非昵称</span></span><br><span class="line">$ git config --global user.email  <span class="string">"xxx@qq.com"</span><span class="comment">// 填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure>

<h3 id="三、-初始化工程"><a href="#三、-初始化工程" class="headerlink" title="三、 初始化工程"></a>三、 初始化工程</h3><h4 id="3-1-全局安装hexo"><a href="#3-1-全局安装hexo" class="headerlink" title="3.1 全局安装hexo"></a>3.1 全局安装hexo</h4><p><strong>① 全局安装hexo</strong></p>
<p>打开终端输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p><strong>②创建hexo项目</strong></p>
<p>在你认为合适的地方新建文件夹，我将其放在d盘新建文件夹命名为hexo</p>
<p>终端切换到这个目录，执行以下命令为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">$ cd d:/hexo  <span class="comment">// 这个命令表示终端切换到d盘hexo目录下</span></span><br><span class="line">$ hexo <span class="keyword">init</span> blog  <span class="comment">// 初始化项目 项目名称为blog 这个过程可能会花费一些时间</span></span><br><span class="line">$ cd blog   <span class="comment">// 切换到blog目录下</span></span><br><span class="line">$ npm install   <span class="comment">// 这一步是安装所需的依赖</span></span><br><span class="line">$ hexo g # 或者hexo generate  <span class="comment">//生成静态文件</span></span><br><span class="line">$ hexo s # 或者hexo server    <span class="comment">//然后就可以在浏览器输入http://localhost:4000/ 就可以在本地查看初始化的项目了</span></span><br></pre></td></tr></table></figure>

<p>目录长这个样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<p>(1)  界面出不来的话可以试一试  <a href="http://localhost:4000//" target="_blank" rel="noopener">http://localhost:4000//</a></p>
<p>(2) 换一个 端口号  hexo server -p 5000</p>
<p>界面长这个样子：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-16c4570d693d9b37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>初始化界面</p>
<h4 id="3-2-下载并安装主题"><a href="#3-2-下载并安装主题" class="headerlink" title="3.2 下载并安装主题"></a>3.2 下载并安装主题</h4><p>一般应该很少人直接使用默认的主题吧，毕竟不是很好看。</p>
<p>我用的主题叫做<code>anisina</code>，因为作者的文档确实写的不太全，所以当时研究主题反而花了很多时间。</p>
<p>我就在这里详细介绍一下我用的主题咋配的吧，大家可以上网搜hexo主题 应该可以找到很多，挑自己喜欢的就行 最好是好看文档又全的，可以省很多事情。</p>
<p>*<em>①下载主题(<a href="https://hexo.io/themes/" target="_blank" rel="noopener">更多主题下载处</a>) *</em></p>
<p>打开终端在d:/hexo/bolg/themes目录下，输入如下命令下载主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Haojen/hexo-theme-Anisina.git</span><br></pre></td></tr></table></figure>

<p><strong>②配置主题 (<a href="http://haojen.github.io/2017/05/09/Anisina-中文使用教程/" target="_blank" rel="noopener">作者提供的api文档</a>)</strong></p>
<p>打开hexo/blog/_config.yml 文件</p>
<p>修改<code>themes: Anisina</code></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6338511-a61f568d2e9bbee9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>修改主题</p>
]]></content>
  </entry>
  <entry>
    <title>rabbitmq原理及基础概念</title>
    <url>/2018/04/11/rabbitmq%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h3><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的<a href="http://www.diggerplus.org/archives/tag/%e4%b8%ad%e9%97%b4%e4%bb%b6" target="_blank" rel="noopener">中间件</a>设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。<br>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。<br>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。<br>下面将重点介绍RabbitMQ中的一些基础概念，了解了这些概念，是使用好RabbitMQ的基础。</p>
<h3 id="ConnectionFactory、Connection、Channel"><a href="#ConnectionFactory、Connection、Channel" class="headerlink" title="ConnectionFactory、Connection、Channel"></a>ConnectionFactory、Connection、Channel</h3><p>ConnectionFactory、Connection、Channel都是RabbitMQ对外提供的API中最基本的对象。Connection是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。ConnectionFactory为Connection的制造工厂。<br>Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。</p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue（队列）是RabbitMQ的内部对象，用于存储消息，用下图表示。<br><img src="https://img2018.cnblogs.com/blog/774371/201908/774371-20190819103814085-804287529.png" alt="img"></p>
<p>RabbitMQ中的消息都只能存储在Queue中，生产者（下图中的P）生产消息并最终投递到Queue中，消费者（下图中的C）可以从Queue中获取消息并消费。</p>
<p><img src="https://img2018.cnblogs.com/blog/774371/201908/774371-20190819103830954-867723738.png" alt="img"></p>
<p>多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p>
<h3 id="Message-acknowledgment"><a href="#Message-acknowledgment" class="headerlink" title="Message acknowledgment"></a>Message acknowledgment</h3><p>在实际应用中，可能会发生消费者收到Queue中的消息，但没有处理完成就宕机（或出现其他意外）的情况，这种情况下就可能会导致消息丢失。为了避免这种情况发生，我们可以要求消费者在消费完消息后发送一个回执给RabbitMQ，RabbitMQ收到消息回执（Message acknowledgment）后才将该消息从Queue中移除；如果RabbitMQ没有收到回执并检测到消费者的RabbitMQ连接断开，则RabbitMQ会将该消息发送给其他消费者（如果存在多个消费者）进行处理。这里不存在timeout概念，一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的RabbitMQ连接断开。<br>这里会产生另外一个问题，如果我们的开发人员在处理完业务逻辑后，忘记发送回执给RabbitMQ，这将会导致严重的bug——Queue中堆积的消息会越来越多；消费者重启后会重复消费这些消息并重复执行业务逻辑…</p>
<h3 id="Message-durability"><a href="#Message-durability" class="headerlink" title="Message durability"></a>Message durability</h3><p>如果我们希望即使在RabbitMQ服务重启的情况下，也不会丢失消息，我们可以将Queue与Message都设置为可持久化的（durable），这样可以保证绝大部分情况下我们的RabbitMQ消息不会丢失。但依然解决不了小概率丢失事件的发生（比如RabbitMQ服务器已经接收到生产者的消息，但还没来得及持久化该消息时RabbitMQ服务器就断电了），如果我们需要对这种小概率事件也要管理起来，那么我们要用到事务。由于这里仅为RabbitMQ的简单介绍，所以这里将不讲解RabbitMQ相关的事务。</p>
<h3 id="Prefetch-count"><a href="#Prefetch-count" class="headerlink" title="Prefetch count"></a>Prefetch count</h3><p>前面我们讲到如果有多个消费者同时订阅同一个Queue中的消息，Queue中的消息会被平摊给多个消费者。这时如果每个消息的处理时间不同，就有可能会导致某些消费者一直在忙，而另外一些消费者很快就处理完手头工作并一直空闲的情况。我们可以通过设置prefetchCount来限制Queue每次发送给每个消费者的消息数，比如我们设置prefetchCount=1，则Queue每次给每个消费者发送一条消息；消费者处理完这条消息后Queue会再给该消费者发送一条消息。</p>
<p><img src="https://img2018.cnblogs.com/blog/774371/201908/774371-20190819104007647-1027286628.png" alt="img"></p>
<h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><p>在上一节我们看到生产者将消息投递到Queue中，实际上这在RabbitMQ中这种事情永远都不会发生。实际的情况是，生产者将消息发送到Exchange（交换器，下图中的X），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。</p>
<p><img src="https://img2018.cnblogs.com/blog/774371/201908/774371-20190819104028789-412276700.png" alt="img"></p>
<p>Exchange是按照什么逻辑将消息路由到Queue的？这个将在Binding一节介绍。<br>RabbitMQ中的Exchange有四种类型，不同的类型有着不同的路由策略，这将在Exchange Types一节介绍。</p>
<h3 id="routing-key"><a href="#routing-key" class="headerlink" title="routing key"></a>routing key</h3><p>生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。<br>在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。<br>RabbitMQ为routing key设定的长度限制为255 bytes。</p>
<h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p>RabbitMQ中通过Binding将Exchange与Queue关联起来，这样RabbitMQ就知道如何正确地将消息路由到指定的Queue了。<br><img src="https://img2018.cnblogs.com/blog/774371/201908/774371-20190819104128931-1338459538.png" alt="img"></p>
<h3 id="Binding-key"><a href="#Binding-key" class="headerlink" title="Binding key"></a>Binding key</h3><p>在绑定（Binding）Exchange与Queue的同时，一般会指定一个binding key；消费者将消息发送给Exchange时，一般会指定一个routing key；当binding key与routing key相匹配时，消息将会被路由到对应的Queue中。这个将在Exchange Types章节会列举实际的例子加以说明。<br>在绑定多个Queue到同一个Exchange的时候，这些Binding允许使用相同的binding key。<br>binding key 并不是在所有情况下都生效，它依赖于Exchange Type，比如fanout类型的Exchange就会无视binding key，而是将消息路由到所有绑定到该Exchange的Queue。</p>
<h3 id="Exchange-Types"><a href="#Exchange-Types" class="headerlink" title="Exchange Types"></a>Exchange Types</h3><p>RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种（AMQP规范里还提到两种Exchange Type，分别为system与自定义，这里不予以描述），下面分别进行介绍。</p>
<h3 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h3><p>fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。<br><img src="https://img2018.cnblogs.com/blog/774371/201908/774371-20190819104152177-2053988251.png" alt="img"></p>
<p>上图中，生产者（P）发送到Exchange（X）的所有消息都会路由到图中的两个Queue，并最终被两个消费者（C1与C2）消费。</p>
<h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p>direct类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中。</p>
<p><img src="https://img2018.cnblogs.com/blog/774371/201908/774371-20190819104210818-1771762193.png" alt="img"></p>
<p>以上图的配置为例，我们以routingKey=”error”发送消息到Exchange，则消息会路由到Queue1（amqp.gen-S9b…，这是由RabbitMQ自动生成的Queue名称）和Queue2（amqp.gen-Agl…）；如果我们以routingKey=”info”或routingKey=”warning”来发送消息，则消息只会路由到Queue2。如果我们以其他routingKey发送消息，则消息不会路由到这两个Queue中。</p>
<h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><p>前面讲到direct类型的Exchange路由规则是完全匹配binding key与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定：</p>
<ul>
<li>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”</li>
<li>binding key与routing key一样也是句点号“. ”分隔的字符串</li>
<li>binding key中可以存在两种特殊字符“<em>”与“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/774371/201908/774371-20190819104233644-253637000.png" alt="img"></p>
<p>以上图中的配置为例，routingKey=”quick.orange.rabbit”的消息会同时路由到Q1与Q2，routingKey=”lazy.orange.fox”的消息会路由到Q1，routingKey=”lazy.brown.fox”的消息会路由到Q2，routingKey=”lazy.pink.rabbit”的消息会路由到Q2（只会投递给Q2一次，虽然这个routingKey与Q2的两个bindingKey都匹配）；routingKey=”quick.brown.fox”、routingKey=”orange”、routingKey=”quick.orange.male.rabbit”的消息将会被丢弃，因为它们没有匹配任何bindingKey。</p>
<h3 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h3><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。<br>在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。<br>该类型的Exchange没有用到过（不过也应该很有用武之地），所以不做介绍。</p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>MQ本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到RabbitMQ后不会知道消费者（C）处理成功或者失败（甚至连有没有消费者来处理这条消息都不知道）。<br>但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于RPC（Remote Procedure Call，远程过程调用）。在RabbitMQ中也支持RPC。</p>
<p><img src="https://img2018.cnblogs.com/blog/774371/201908/774371-20190819104253450-1490098886.png" alt="img"></p>
<p>RabbitMQ中实现RPC的机制是：</p>
<ul>
<li>客户端发送请求（消息）时，在消息的属性（MessageProperties，在AMQP协议中定义了14中properties，这些属性会随着消息一起发送）中设置两个值replyTo（一个Queue名称，用于告诉服务器处理完成后将通知我的消息发送到这个Queue中）和correlationId（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败）</li>
<li>服务器端收到消息并处理</li>
<li>服务器端处理完消息后，将生成一条应答消息到replyTo指定的Queue，同时带上correlationId属性</li>
<li>客户端之前已订阅replyTo指定的Queue，从中收到服务器的应答消息后，根据其中的correlationId属性分析哪条请求被执行了，根据执行结果进行后续业务处理</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>UUID码</title>
    <url>/2018/03/14/UUID%E7%A0%81/</url>
    <content><![CDATA[<h3 id="UUID码"><a href="#UUID码" class="headerlink" title="UUID码"></a>UUID码</h3><blockquote>
<p> UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为<a href="https://baike.baidu.com/item/开放软件基金会/1223731" target="_blank" rel="noopener">开放软件基金会</a>组织在<a href="https://baike.baidu.com/item/分布式计算/85448" target="_blank" rel="noopener">分布式计算</a>环境领域的一部分。其目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。</p>
</blockquote>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和随机数。</p>
<p>UUID由以下几部分的组合：</p>
<p>（1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。</p>
<p>（2）时钟序列。</p>
<p>（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</p>
<p>UUID的唯一缺陷在于<u>生成的结果串会比较长</u>。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单地生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，可以从cflib 下载CreateGUID() UDF进行转换。</p>
<hr>
<p> python有一个模块叫做uuid，导入它就可以使用它的四个方法了。注意这四个方法依次是uuid1(),uuid3(),uuid4(),uuid5(),然而<strong>并没有uuid2()</strong></p>
<ol>
<li><p><strong>基于时间戳</strong><br> 使用主机ID, 序列号, 和当前时间来生成UUID, 可保证全球范围的唯一性. 但由于使用该方法生成的UUID中包含有主机的网络地址, 因此可能危及隐私.</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    uuid.uuid1(node=<span class="literal">None</span>, clock_seq=<span class="literal">None</span>)</span><br><span class="line">In [<span class="number">1</span>]: uuid.uuid1()</span><br><span class="line">    Out[<span class="number">2</span>]: UUID(<span class="string">'bd6a74ec-f8ae-11e9-bad5-f8a2d6d4d3ac'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p> 打断一下…</p>
<p> 在<code>uuid3()</code> 和 <code>uuid5()</code> 两个方法里涉及到了一个 <code>namespace</code> 的参数，python提供了四种生成namespace的方法。</p>
<blockquote>
<p><code>uuid.NAMESPACE_DNS</code> : 指定此命名空间时，名称字符串是完全限定的域名</p>
<p><code>uuid.NAMESPACE_URL</code>: 指定此命名空间时，名称字符串是URL</p>
<p><code>uuid.NAMESPACE_OID</code>: 指定此命名空间时，名称字符串是ISO OID</p>
<p><code>uuid.namespace_x500</code>:  the <em>name</em> string is an X.500 DN in DER or a text output format (咱也不懂，也不敢问)</p>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p><strong>基于名字的MD5散列值</strong></p>
<p>  通过计算命名空间和名字的MD5散列值来生成UUID, 可以保证同一命名空间中不同名字的唯一性和不同命名空间的唯一性, 但同一命名空间的同一名字生成的UUID相同 </p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">uuid.uuid3(namespace, name)</span><br><span class="line">In [<span class="number">9</span>]: uuid.uuid3(uuid.NAMESPACE_URL,<span class="string">'python.org'</span>)</span><br><span class="line">Out[<span class="number">9</span>]: UUID(<span class="string">'22fe6191-c161-3d86-a432-a81f343eda08'</span>)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p><strong>基于随机数</strong> </p>
<p>通过随机数来生成UUID. 使用的是伪随机数有一定的重复概率 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: uuid.uuid4()</span><br><span class="line">Out[<span class="number">10</span>]: UUID(<span class="string">'0faccaf9-d093-41c9-ac18-1cee7dcf4c72'</span>)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p><strong>基于名字的SHA-1散列值</strong> </p>
<p>算法与 <code>uuid3()</code> 相同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: uuid.uuid5(uuid.NAMESPACE_URL,<span class="string">'python.org'</span>)</span><br><span class="line">Out[<span class="number">11</span>]: UUID(<span class="string">'7af94e2b-4dd9-50f0-9c9a-8a48519bdef0'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>git服务搭建</title>
    <url>/2017/08/21/git%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="创建用户账号"><a href="#创建用户账号" class="headerlink" title="创建用户账号"></a>创建用户账号</h1><p>添加用户： useradd  test_user</p>
<p>设置密码： passwd test_user </p>
<p>登录： ssh <a href="mailto:test_user@62.234.92.111" target="_blank" rel="noopener">test_user@62.234.92.111</a>          命令格式：     ssh    用户名@ip地址</p>
<h1 id="使用公钥私钥登录"><a href="#使用公钥私钥登录" class="headerlink" title="使用公钥私钥登录"></a>使用公钥私钥登录</h1><h2 id="配置sshd服务参数"><a href="#配置sshd服务参数" class="headerlink" title="配置sshd服务参数"></a>配置sshd服务参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line">RSAAuthentication yes   # 启用RSA 非对称加密算法</span><br><span class="line">PubkeyAuthentication yes   # 公钥认证</span><br><span class="line">PasswordAuthentication yes  #允许密码认证</span><br></pre></td></tr></table></figure>

<p>修改配置后需要重启服务：  systemctl restart sshd.service</p>
<h2 id="创建ssh权限目录和文件"><a href="#创建ssh权限目录和文件" class="headerlink" title="创建ssh权限目录和文件"></a>创建ssh权限目录和文件</h2><p>生成公钥私钥： ssh-keygen</p>
<p>切换用户   su - test_user</p>
<p>创建文件夹：  mkdir .ssh   </p>
<p>设置.ssh目录权限   chmod 700 .ssh</p>
<p>创建文件： touch .ssh/authorized_keys</p>
<p>设置authorized_keys权限   chmod 600 .ssh/authorized_keys</p>
<p>使用证书登录   ssh <a href="mailto:test_user@62.234.92.111" target="_blank" rel="noopener">test_user@62.234.92.111</a>   -i 证书路径</p>
<h1 id="搭建git服务"><a href="#搭建git服务" class="headerlink" title="搭建git服务"></a>搭建git服务</h1><p>创建git用户    useradd git</p>
<p>设置git用户ssh权限目录和文件</p>
<p>创建一个裸版本库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - git                            # 登录git用户</span><br><span class="line">git init --bare project.git         # 创建一个裸仓库</span><br></pre></td></tr></table></figure>



<h2 id="创建一个文件并提交"><a href="#创建一个文件并提交" class="headerlink" title="创建一个文件并提交"></a>创建一个文件并提交</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch readme.txt                          # 创建readme.txt 文件</span><br><span class="line">git add readme.txt                         # 添加到暂存区中 </span><br><span class="line">git commit -m &quot;添加readme文件&quot;              # 提交到本地版本库里</span><br><span class="line">git push origin                            # 推送到远程仓库</span><br><span class="line">git pull origin                           # 拉取文件</span><br></pre></td></tr></table></figure>



<h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git</span><br></pre></td></tr></table></figure>









]]></content>
  </entry>
  <entry>
    <title>git bush 中的一些项目操作</title>
    <url>/2017/05/29/git%20bush%20%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A1%B9%E7%9B%AE%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="git-bush-中的一些项目操作"><a href="#git-bush-中的一些项目操作" class="headerlink" title="git bush 中的一些项目操作"></a>git bush 中的一些项目操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 创建功能分支</span><br><span class="line">git flow feature start 分支名称</span><br><span class="line">// 推送远程仓库留档</span><br><span class="line">git flow feature publish 分支名称</span><br><span class="line">// 完成并保存本地分支</span><br><span class="line">git flow feature finish -k 分支名称</span><br><span class="line">// 合并功能分支到dev</span><br><span class="line">git checkout develop // 切换分支</span><br><span class="line">git pull origin develop // 更新远端仓库至本地</span><br><span class="line">git merge feature/分支名  // 合并至dev分支</span><br><span class="line">git push origin develop // 推送远端仓库</span><br><span class="line"></span><br><span class="line">// other opt</span><br><span class="line">git push origin --delete 分支名称 // 删除远端仓库分支</span><br><span class="line">git branch -d/-D(强制删除) 分支名称 // 删除本地仓库分支</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>生成随机字符串</title>
    <url>/2016/11/05/%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">tmp = os.urandom(<span class="number">44</span>)</span><br><span class="line">secret_key = base64.b64encode(tmp)</span><br><span class="line">print(secret_key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_secret_key</span><span class="params">(length=<span class="number">12</span>, allowed_chars=None, secret_key=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生成随机字符串</span></span><br><span class="line"><span class="string">    :param length: 随机字符串长度</span></span><br><span class="line"><span class="string">    :param allowed_chars: 随机字符串字符取值范围</span></span><br><span class="line"><span class="string">    :param secret_key: 生成随机字符串的随机字符串</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> secret_key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        secret_key = <span class="string">"n&amp;^-9#k*-6pwzsjt-qsc@s3$l46k(7e%f80e7gx^f#vouf3yvz"</span></span><br><span class="line">    <span class="keyword">if</span> allowed_chars <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        allowed_chars = <span class="string">'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*(-_=+)'</span></span><br><span class="line"></span><br><span class="line">    random.seed(</span><br><span class="line">        hashlib.sha256(</span><br><span class="line">            (<span class="string">"%s%s%s"</span> % (</span><br><span class="line">                random.getstate(),</span><br><span class="line">                time.time(),</span><br><span class="line">                secret_key)).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">        ).digest())</span><br><span class="line">    ret = <span class="string">''</span>.join(random.choice(allowed_chars) <span class="keyword">for</span> i <span class="keyword">in</span> range(length))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>flask在服务器上运行</title>
    <url>/2016/10/10/flask%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<p>1.上传项目<br>将项目文件使用Xftp上传至某目录下</p>
<p>2.修改nginx配置文件<br>在/etc/nginx/conf.d/文件夹下找到其配置文件<br>添加nginx 需要监听的端口信息<br>末尾添加类似代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8001;</span><br><span class="line">    #主机公网IP</span><br><span class="line">    server_name instagram.zhyh2010.com;</span><br><span class="line">    location /&#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:8000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上， 我们将外部通过 8001 端口发送过来的请求， 代理给了 127.0.0.1:8000 也就是我们的 flask 项目</p>
<p>3.配置文件修改重装载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<p>附Nginx操作代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#重启服务：</span><br><span class="line">service nginx restart</span><br><span class="line"></span><br><span class="line">#快速停止或关闭Nginx：</span><br><span class="line">nginx -s stop</span><br><span class="line"></span><br><span class="line"> 正常停止或关闭Nginx：</span><br><span class="line">nginx -s quit</span><br><span class="line"></span><br><span class="line"> 配置文件修改重装载命令：</span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line">查看端口运行状态：</span><br><span class="line">netstat -ntlp</span><br></pre></td></tr></table></figure>

<p>运行程序<br>进入项目目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#确保已装flask</span><br><span class="line">pip install flask</span><br><span class="line">#运行程序</span><br><span class="line">python app.py</span><br></pre></td></tr></table></figure>

<p>————————————————</p>
]]></content>
  </entry>
  <entry>
    <title>python开发规范</title>
    <url>/2016/09/25/python%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p><img src="/2016/09/25/python%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/default.jpg" alt="123"></p>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>Tip</p>
<p>不要在行尾加分号, 也不要用分号将两条命令放在同一行.</p>
<h2 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h2><p>Tip</p>
<p>每行不超过80个字符</p>
<p>例外:</p>
<ol>
<li>长的导入模块语句</li>
<li>注释里的URL</li>
</ol>
<p>不要使用反斜杠连接行.</p>
<p>Python会将 <a href="http://docs.python.org/2/reference/lexical_analysis.html#implicit-line-joining" target="_blank" rel="noopener">圆括号, 中括号和花括号中的行隐式的连接起来</a> , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: foo_bar(self, width, height, color=<span class="string">'black'</span>, design=<span class="literal">None</span>, x=<span class="string">'foo'</span>,</span><br><span class="line">             emphasis=<span class="literal">None</span>, highlight=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (width == <span class="number">0</span> <span class="keyword">and</span> height == <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">         color == <span class="string">'red'</span> <span class="keyword">and</span> emphasis == <span class="string">'strong'</span>):</span><br></pre></td></tr></table></figure>

<p>如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = (<span class="string">'This will build a very long long '</span></span><br><span class="line">     <span class="string">'long long long long long long string'</span>)</span><br></pre></td></tr></table></figure>

<p>在注释中，如果必要，将长的URL放在一行上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:  <span class="comment"># See details at</span></span><br><span class="line">      <span class="comment"># http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html</span></span><br><span class="line">No:  <span class="comment"># See details at</span></span><br><span class="line">     <span class="comment"># http://www.example.com/us/developer/documentation/api/content/\</span></span><br><span class="line">     <span class="comment"># v2.0/csv_file_name_extension_full_specification.html</span></span><br></pre></td></tr></table></figure>

<p>注意上面例子中的元素缩进; 你可以在本文的 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/#indentation" target="_blank" rel="noopener">缩进</a> 部分找到解释.</p>
<h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><p>Tip</p>
<p>宁缺毋滥的使用括号</p>
<p>除非是用于实现行连接, 否则不要在返回语句或条件语句中使用括号. 不过在元组两边使用括号是可以的.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> foo:</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">while</span> x:</span><br><span class="line">         x = bar()</span><br><span class="line">     <span class="keyword">if</span> x <span class="keyword">and</span> y:</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">return</span> foo</span><br><span class="line">     <span class="keyword">for</span> (x, y) <span class="keyword">in</span> dict.items(): ...</span><br><span class="line">No:  <span class="keyword">if</span> (x):</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span>(x):</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">return</span> (foo)</span><br></pre></td></tr></table></figure>



<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>Tip</p>
<p>用4个空格来缩进代码</p>
<p>绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素(见 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/#line-length" target="_blank" rel="noopener">行长度</a> 部分的示例), 或者使用4空格的悬挂式缩进(这时第一行不应该有参数):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:   <span class="comment"># Aligned with opening delimiter</span></span><br><span class="line">       foo = long_function_name(var_one, var_two,</span><br><span class="line">                                var_three, var_four)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># Aligned with opening delimiter in a dictionary</span></span><br><span class="line">       foo = &#123;</span><br><span class="line">           long_dictionary_key: value1 +</span><br><span class="line">                                value2,</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 4-space hanging indent; nothing on first line</span></span><br><span class="line">       foo = long_function_name(</span><br><span class="line">           var_one, var_two, var_three,</span><br><span class="line">           var_four)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 4-space hanging indent in a dictionary</span></span><br><span class="line">       foo = &#123;</span><br><span class="line">           long_dictionary_key:</span><br><span class="line">               long_dictionary_value,</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">No:    <span class="comment"># Stuff on first line forbidden</span></span><br><span class="line">      foo = long_function_name(var_one, var_two,</span><br><span class="line">          var_three, var_four)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 2-space hanging indent forbidden</span></span><br><span class="line">      foo = long_function_name(</span><br><span class="line">        var_one, var_two, var_three,</span><br><span class="line">        var_four)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># No hanging indent in a dictionary</span></span><br><span class="line">      foo = &#123;</span><br><span class="line">          long_dictionary_key:</span><br><span class="line">              long_dictionary_value,</span><br><span class="line">              ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>Tip</p>
<p>顶级定义之间空两行, 方法定义之间空一行</p>
<p>顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.</p>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>Tip</p>
<p>按照标准的排版规范来使用标点两边的空格</p>
<p>括号内不要有空格.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: spam(ham[<span class="number">1</span>], &#123;eggs: <span class="number">2</span>&#125;, [])</span><br><span class="line">No:  spam( ham[ <span class="number">1</span> ], &#123; eggs: <span class="number">2</span> &#125;, [ ] )</span><br></pre></td></tr></table></figure>

<p>不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> x == <span class="number">4</span>:</span><br><span class="line">         <span class="keyword">print</span> x, y</span><br><span class="line">     x, y = y, x</span><br><span class="line">No:  <span class="keyword">if</span> x == <span class="number">4</span> :</span><br><span class="line">         <span class="keyword">print</span> x , y</span><br><span class="line">     x , y = y , x</span><br></pre></td></tr></table></figure>

<p>参数列表, 索引或切片的左括号前不应加空格.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: spam(<span class="number">1</span>)</span><br><span class="line">no: spam (<span class="number">1</span>)</span><br><span class="line">Yes: dict[<span class="string">'key'</span>] = list[index]</span><br><span class="line">No:  dict [<span class="string">'key'</span>] = list [index]</span><br></pre></td></tr></table></figure>

<p>在二元操作符两边都加上一个空格, 比如赋值(=), 比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not), 布尔(and, or, not). 至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: x == <span class="number">1</span></span><br><span class="line">No:  x&lt;<span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>当’=’用于指示关键字参数或默认参数值时, 不要在其两侧使用空格.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag=<span class="number">0.0</span>)</span>:</span> <span class="keyword">return</span> magic(r=real, i=imag)</span><br><span class="line">No:  <span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag = <span class="number">0.0</span>)</span>:</span> <span class="keyword">return</span> magic(r = real, i = imag)</span><br></pre></td></tr></table></figure>

<p>不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:</span><br><span class="line">     foo = <span class="number">1000</span>  <span class="comment"># comment</span></span><br><span class="line">     long_name = <span class="number">2</span>  <span class="comment"># comment that should not be aligned</span></span><br><span class="line"></span><br><span class="line">     dictionary = &#123;</span><br><span class="line">         <span class="string">"foo"</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="string">"long_name"</span>: <span class="number">2</span>,</span><br><span class="line">         &#125;</span><br><span class="line">No:</span><br><span class="line">     foo       = <span class="number">1000</span>  <span class="comment"># comment</span></span><br><span class="line">     long_name = <span class="number">2</span>     <span class="comment"># comment that should not be aligned</span></span><br><span class="line"></span><br><span class="line">     dictionary = &#123;</span><br><span class="line">         <span class="string">"foo"</span>      : <span class="number">1</span>,</span><br><span class="line">         <span class="string">"long_name"</span>: <span class="number">2</span>,</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Tip</p>
<p>确保对模块, 函数, 方法和行内注释使用正确的风格</p>
<p><strong>文档字符串</strong></p>
<blockquote>
<p>Python有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的<strong>doc</strong>成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号”“”( <a href="http://www.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">PEP-257</a> ). 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范.</p>
</blockquote>
<p><strong>模块</strong></p>
<blockquote>
<p>每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板.</p>
</blockquote>
<p><strong>函数和方法</strong></p>
<blockquote>
<p>下文所指的函数,包括函数, 方法, 以及生成器.</p>
<p>一个函数必须要有文档字符串, 除非它满足以下条件:</p>
<ol>
<li>外部不可见</li>
<li>非常短小</li>
<li>简单明了</li>
</ol>
<p>文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述”怎么做”, 除非是一些复杂的算法. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有意义.</p>
<p>关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述. 每节应该以一个标题行开始. 标题行以冒号结尾. 除标题行外, 节的其他内容应被缩进2个空格.</p>
<ul>
<li><p>Args:</p>
<p>列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受<em>foo(可变长度参数列表)或者*</em>bar (任意关键字参数), 应该详细列出<em>foo和*</em>bar.</p>
</li>
<li><p>Returns: (或者 Yields: 用于生成器)</p>
<p>描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略.</p>
</li>
<li><p>Raises:</p>
<p>列出与接口有关的所有异常.</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_bigtable_rows</span><span class="params">(big_table, keys, other_silly_variable=None)</span>:</span></span><br><span class="line">    <span class="string">"""Fetches rows from a Bigtable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Retrieves rows pertaining to the given keys from the Table instance</span></span><br><span class="line"><span class="string">    represented by big_table.  Silly things may happen if</span></span><br><span class="line"><span class="string">    other_silly_variable is not None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        big_table: An open Bigtable Table instance.</span></span><br><span class="line"><span class="string">        keys: A sequence of strings representing the key of each table row</span></span><br><span class="line"><span class="string">            to fetch.</span></span><br><span class="line"><span class="string">        other_silly_variable: Another optional variable, that has a much</span></span><br><span class="line"><span class="string">            longer name than the other args, and which does nothing.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        A dict mapping keys to the corresponding table row data</span></span><br><span class="line"><span class="string">        fetched. Each row is represented as a tuple of strings. For</span></span><br><span class="line"><span class="string">        example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#123;'Serak': ('Rigel VII', 'Preparer'),</span></span><br><span class="line"><span class="string">         'Zim': ('Irk', 'Invader'),</span></span><br><span class="line"><span class="string">         'Lrrr': ('Omicron Persei 8', 'Emperor')&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If a key from the keys argument is missing from the dictionary,</span></span><br><span class="line"><span class="string">        then that row was not found in the table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        IOError: An error occurred accessing the bigtable.Table object.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>类</strong></p>
<blockquote>
<p>类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Summary of class here.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Longer class information....</span></span><br><span class="line"><span class="string">    Longer class information....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        likes_spam: A boolean indicating if we like SPAM or not.</span></span><br><span class="line"><span class="string">        eggs: An integer count of the eggs we have laid.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, likes_spam=False)</span>:</span></span><br><span class="line">        <span class="string">"""Inits SampleClass with blah."""</span></span><br><span class="line">        self.likes_spam = likes_spam</span><br><span class="line">        self.eggs = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Performs operation blah."""</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>块注释和行注释</strong></p>
<blockquote>
<p>最需要写注释的是代码中那些技巧性的部分. 如果你在下次 <a href="http://en.wikipedia.org/wiki/Code_review" target="_blank" rel="noopener">代码审查</a> 的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># We use a weighted dictionary search to find out where i is in</span></span><br><span class="line"><span class="comment"># the array.  We extrapolate position based on the largest num</span></span><br><span class="line"><span class="comment"># in the array and the array size and then do binary search to</span></span><br><span class="line"><span class="comment"># get the exact number.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &amp; (i<span class="number">-1</span>) == <span class="number">0</span>:        <span class="comment"># True if i is 0 or a power of 2.</span></span><br></pre></td></tr></table></figure>

<p>为了提高可读性, 注释应该至少离开代码2个空格.</p>
<p>另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BAD COMMENT: Now go through the b array and make sure whenever i occurs</span></span><br><span class="line"><span class="comment"># the next element is i+1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Tip</p>
<p>如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span></span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">         <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span><span class="params">(object)</span>:</span></span><br><span class="line">             <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span><span class="params">(ParentClass)</span>:</span></span><br><span class="line">         <span class="string">"""Explicitly inherits from another class already."""</span></span><br><span class="line">No: <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>继承自 <code>object</code> 是为了使属性(properties)正常工作, 并且这样可以保护你的代码, 使其不受 <a href="http://www.python.org/dev/peps/pep-3000/" target="_blank" rel="noopener">PEP-3000</a> 的一个特殊的潜在不兼容性影响. 这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 包括 <code>__new__, __init__, __delattr__, __getattribute__, __setattr__, __hash__, __repr__, and __str__</code> .</p>
<h2 id="导入格式"><a href="#导入格式" class="headerlink" title="导入格式"></a>导入格式</h2><p>Tip</p>
<p>每个导入应该独占一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对的 </span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#错的</span></span><br><span class="line"><span class="keyword">import</span> os, sys</span><br></pre></td></tr></table></figure>

<p>导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组:</p>
<ol>
<li>标准库导入</li>
<li>第三方库导入</li>
<li>应用程序指定导入</li>
</ol>
<p>每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo</span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br><span class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> baz</span><br><span class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> Quux</span><br><span class="line"><span class="keyword">from</span> Foob <span class="keyword">import</span> ar</span><br></pre></td></tr></table></figure>

<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>Tip</p>
<p>通常每个语句应该独占一行</p>
<p>不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行. 如果是if语句, 只有在没有else时才能这样做. 特别地, 绝不要对 <code>try/except</code> 这样做, 因为try和except不能放在同一行.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对的</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> foo: bar(foo)</span><br><span class="line"><span class="comment">#错的</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> foo: bar(foo)</span><br><span class="line">  <span class="keyword">else</span>:   baz(foo)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>:               bar(foo)</span><br><span class="line">  <span class="keyword">except</span> ValueError: baz(foo)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      bar(foo)</span><br><span class="line">  <span class="keyword">except</span> ValueError: baz(foo)</span><br></pre></td></tr></table></figure>



<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name.</p>
<p><strong>应该避免的名称</strong></p>
<blockquote>
<ol>
<li>单字符名称, 除了计数器和迭代器.</li>
<li>包/模块名中的连字符(-)</li>
<li>双下划线开头并结尾的名称(Python保留, 例如<strong>init</strong>)</li>
</ol>
</blockquote>
<p><strong>命名约定</strong></p>
<blockquote>
<ol>
<li>所谓”内部(Internal)”表示仅模块内可用, 或者, 在类内是保护或私有的.</li>
<li>用单下划线(_)开头表示模块变量或函数是protected的(使用from module import *时不会包含).</li>
<li>用双下划线(__)开头的实例变量或方法表示类内私有.</li>
<li>将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.</li>
<li>对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.</li>
</ol>
</blockquote>
<p><strong>Python之父Guido推荐的规范</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Public</th>
<th>Internal</th>
</tr>
</thead>
<tbody><tr>
<td>Modules</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr>
<td>Packages</td>
<td>lower_with_under</td>
<td></td>
</tr>
<tr>
<td>Classes</td>
<td>CapWords</td>
<td>_CapWords</td>
</tr>
<tr>
<td>Exceptions</td>
<td>CapWords</td>
<td></td>
</tr>
<tr>
<td>Functions</td>
<td>lower_with_under()</td>
<td>_lower_with_under()</td>
</tr>
<tr>
<td>Global/Class Constants</td>
<td>CAPS_WITH_UNDER</td>
<td>_CAPS_WITH_UNDER</td>
</tr>
<tr>
<td>Global/Class Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr>
<td>Instance Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under (protected) or __lower_with_under (private)</td>
</tr>
<tr>
<td>Method Names</td>
<td>lower_with_under()</td>
<td>_lower_with_under() (protected) or __lower_with_under() (private)</td>
</tr>
<tr>
<td>Function/Method Parameters</td>
<td>lower_with_under</td>
<td></td>
</tr>
<tr>
<td>Local Variables</td>
<td>lower_with_under</td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
</search>
