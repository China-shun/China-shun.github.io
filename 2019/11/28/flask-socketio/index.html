
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>flask-socketio - 铿锵小顺的博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Clang Shun的博客，主要涉及到编程（Java，Python，Linux等），个人提升学习，视频教程，《肯定会软件技术》电台节目 keywords: wistbean，supervisor，java，python，电台，教程,


flask-socketio
Installation(安装)
Requirements(依赖)
Initialization(初始化)
Receiving Messages(接收消息) ==,"> 
    <meta name="author" content="Shun"> 
    <link rel="alternative" href="atom.xml" title="铿锵小顺的博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>

<body class="loading">
    <span id="config-title" style="display:none">铿锵小顺的博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" target="_blank" rel="noopener" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">flask-socketio</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" target="_blank" rel="noopener" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;" target="_blank" rel="noopener"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">flask-socketio</h1>
        <div class="stuff">
            <span>十一月 28, 2019</span>
            

        </div>
        <div class="content markdown">
            <!-- vim-markdown-toc GFM -->

<ul>
<li><a href="#flask-socketio">flask-socketio</a><ul>
<li><a href="#installation安装">Installation(安装)</a></li>
<li><a href="#requirements依赖">Requirements(依赖)</a></li>
<li><a href="#initialization初始化">Initialization(初始化)</a></li>
<li><a href="#receiving-messages接收消息-">Receiving Messages(接收消息) ==</a></li>
<li><a href="#sending-messages发送消息">Sending Messages(发送消息)</a></li>
<li><a href="#broadcasting广播">Broadcasting(广播)</a></li>
<li><a href="#rooms房间">Rooms(房间)</a></li>
<li><a href="#connection-events连接事件">Connection Events(连接事件)</a></li>
<li><a href="#class-based-namespaces基于类的命名空间">Class-Based Namespaces(基于类的命名空间)</a></li>
<li><a href="#error-handling">Error Handling</a></li>
<li><a href="#access-to-flasks-context-globals访问flask的全局上下文">Access to Flask’s Context Globals(访问Flask的全局上下文)</a></li>
<li><a href="#authentication验证">Authentication(验证)</a></li>
<li><a href="#使用带有flask-socketio的flask-login">使用带有Flask-SocketIO的Flask-Login</a></li>
<li><a href="#deployment部署">Deployment(部署)</a><ul>
<li><a href="#using-nginx-as-a-websocket-reverse-proxy使用nginx作为websocket反向代理">Using nginx as a WebSocket Reverse Proxy(使用nginx作为WebSocket反向代理)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#todo">TODO</a><ul>
<li><a href="#using-multiple-workers使用多个工作者">Using Multiple Workers(使用多个工作者)</a></li>
<li><a href="#emitting-from-an-external-process">Emitting from an External Process</a></li>
</ul>
</li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- vim-markdown-toc -->


<h1 id="flask-socketio"><a href="#flask-socketio" class="headerlink" title="flask-socketio"></a>flask-socketio</h1><p><em>Flask-SocketIO</em> 给Flask应用提供了客户端和服务端低延时双向通信。客户端这边应用程序可以使用<br>Javascript，C++，Java，Swift的官方SocketIO库,或者兼容客户端向服务端建立一个持久链接的编程语言<br>中任意一个官方[[<a href="http://socket.io/|SocketIO]]库。" target="_blank" rel="noopener">http://socket.io/|SocketIO]]库。</a></p>
<h2 id="Installation-安装"><a href="#Installation-安装" class="headerlink" title="Installation(安装)"></a>Installation(安装)</h2><p><code>pip install flask-socketio</code></p>
<h2 id="Requirements-依赖"><a href="#Requirements-依赖" class="headerlink" title="Requirements(依赖)"></a>Requirements(依赖)</h2><p>Flask-SocketIO兼容python2.7和python3.3+。Flask-SocketIO包的异步服务依赖于以下三种选择:</p>
<ul>
<li><a href="http://eventlet.net/" target="_blank" rel="noopener">eventlet</a>是最好的选择,支持长轮询和WebSocket传输</li>
<li><a href="http://www.gevent.org/" target="_blank" rel="noopener">gevent</a>支持不同的配置。长轮询在gevent包里被完全支持,但是不像eventlet，gevent自己并不支持WebSocket。为了支持WebSocket当前有两个选择。安装<a href="https://pypi.python.org/pypi/gevent-websocket/" target="_blank" rel="noopener">gevent-websocket</a>包和使用<a href="https://uwsgi-docs.readthedocs.io/en/latest/" target="_blank" rel="noopener">uWSGI</a>web服务，uWSGI提供WebSocket功能。gevent也是一个不错的选择，但是略低于eventlet。</li>
<li>基于Werkzeug的Flask开发服务也可以用，但是给出警告，它的性能低于前两个选择，所以它应该被用于开发中。这个选项只支持长轮训传输。</li>
</ul>
<p>采用哪个异步框架取决于本机安装了什么。优先使用eventlet，gevent次之。对于gevent中支持WebScket， uWSGI优先，gevent-websocket次之。如果既没有eventlet也没有gevent安装，那么使用Flask开发服务。</p>
<p>如果使用多进程，消息队列服务将被用于协调操作，例如广播。支持的队列有<a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>,<a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>,和任意支持<a href="http://kombu.readthedocs.org/en/latest/" target="_blank" rel="noopener">Kombu</a>包的消息队列。</p>
<p>客户端这边，官方的Socket.IO Javascript客户端库可以用来和服务端建立连接。这里也有些用Swift，Java，C++写的官方客户端。非官方客户端可能也能工作，只要实现了<a href="https://github.com/socketio/socket.io-protocol" target="_blank" rel="noopener">Socket.IO协议</a></p>
<h2 id="Initialization-初始化"><a href="#Initialization-初始化" class="headerlink" title="Initialization(初始化)"></a>Initialization(初始化)</h2><p>下面代码例子展示了如何在Flask应用中添加Flask-SocketIO：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"><span class="keyword">from</span> flask_socketio imoprt SocketIO</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SECRET_KEY'</span>] = <span class="string">'secret!'</span></span><br><span class="line">socketio = SocketIO(app)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    socketio.run(app)</span><br></pre></td></tr></table></figure>
<p>init_app()风格的初始化也是被支持的。注意这种方式中web服务被启动了。socketio.run()方法封装了web服务的启动并且替代了app.run()来启动Flask开发服务。当应用在debug模式Werkzeug开发服务将被使用并且是在socketio.run()来配置属性。在生产模式如果eventlet有效，eventlet web服务将被使用，否则使用gevent的。如果eventlet和gevent都没安装，将使用Werkzeug开发web服务。</p>
<p>Flask 0.11引入的”flask运行命令”可以用来启动基于Werkzeug的Flask-SocketIO开发服务，但是这种方式启动由于缺少对WebSocket支持而被不推荐。这个包（flask-socket）的之前版本包含了“flask运行命令”，允许使用eventlet和gevent的WebSocket生产服务。但是这个功能已经在上面展示的socketio.run(app)中停止了。</p>
<p>这个应用只能服务于客户端页面。客户端加载了Socket.IO库和建立连接。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> socket = io.connect(<span class="string">'http://'</span> + <span class="built_in">document</span>.domain + <span class="string">':'</span> + location.port);</span><br><span class="line">    socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        socket.emit(<span class="string">'my event'</span>, &#123;<span class="attr">data</span>: <span class="string">'I\'m connected!'</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Receiving-Messages-接收消息"><a href="#Receiving-Messages-接收消息" class="headerlink" title="Receiving Messages(接收消息) =="></a>Receiving Messages(接收消息) ==</h2><p>当使用SocketIO，消息被事件的两端接收。客户端这边使用Javascript回调。使用Flask-SocketIO,服务端需要注册这些事件的处理，类似路由通过视图函数处理。</p>
<p>下面例子给一个无名事件创建服务端这边的事件处理函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    print(<span class="string">'received message: '</span> + message)</span><br></pre></td></tr></table></figure>
<p>上线例子使用字符消息。另一个无名事件使用JSON数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('json')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_json</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'received json:'</span> + str(json))</span><br></pre></td></tr></table></figure>
<p>最灵活的事件类型是自定义事件名称。这些事件的消息数据可以是string,bytes，int或者JSON:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'received json:'</span> _ str(json))</span><br></pre></td></tr></table></figure>
<p>自定义名称事件也支持多参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(args1, args2, args3)</span>:</span></span><br><span class="line">    print(<span class="string">'received args:'</span> + args1 + args2 + args3)</span><br></pre></td></tr></table></figure>
<p>命名事件是非常灵活的，因为它们不需要包括额外元数据来描述消息类型。<br>Flask-SocketIO也支持SocketIO命名空间，命名空间允许客户端通过多个不同独立连接在同一个物理socket上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event', namespace='/test')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_namespace_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'receviced json:'</span> + str(json))</span><br></pre></td></tr></table></figure>
<p>当命名空间没有指定，默认全局命名空间’/‘将被使用。<br>对于某些时候装饰器语法并不方便，on_event方法可以使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function_handler</span><span class="params">(darta)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">socketio.on_event(<span class="string">'my event'</span>, my_function_handler, namespace=<span class="string">'/test'</span>)</span><br></pre></td></tr></table></figure>
<p>客户端要求服务端回复一个确认收到客户端发来消息的应答,处理函数返回的任何值都将传给客户端作为回调函数的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    print(<span class="string">'received json:'</span> + str(json))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'one'</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子，客户端回调函数携带两个参数进行调用，’one’和2。如果处理函数没有任何返回值，客户端回调函数将不携带任何参数进行调用。</p>
<h2 id="Sending-Messages-发送消息"><a href="#Sending-Messages-发送消息" class="headerlink" title="Sending Messages(发送消息)"></a>Sending Messages(发送消息)</h2><p>之前章节里定义的SocketIO事件处理函数可以通过send()和emit()函数发送回复消息给连接的客户端。</p>
<p>下面例子将收到的消息返回给发送过来的客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> send, emit</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    send(message)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@socketio.on('json')    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_json</span><span class="params">(json)</span>:</span></span><br><span class="line">    send(json, json=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@socketio.on('my event')    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_envent</span><span class="params">(json)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, json)</span><br></pre></td></tr></table></figure>
<p>注意send()和emit()如何被用来分别给无名和命名事件发送消息的</p>
<p>当使用了命名空间，send()和emit()将默认使用发来消息的命名空间。可以通过指定可选参数namespace来给不同命名空间发送消息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    send(message, namespace=<span class="string">'/chat'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, json, namespace=<span class="string">'/chat'</span>)</span><br></pre></td></tr></table></figure>
<p>为了发送多个参数的事件，通过发送一个元组来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(json)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, (<span class="string">'foo'</span>, <span class="string">'bar'</span>, json), namespace=<span class="string">'/chat'</span>)</span><br></pre></td></tr></table></figure>
<p>使用回调时，Javascript客户端根据收到的消息来调用回调函数。客户端应用执行回调函数之后服务端调用相应的服务端回调。如果客户端的回调携带参数调用，这些参数也将作为服务端回调的参数</p>
<h2 id="Broadcasting-广播"><a href="#Broadcasting-广播" class="headerlink" title="Broadcasting(广播)"></a>Broadcasting(广播)</h2><p>另一个非常有用的SocketIO特性是消息广播。Flask-SocketIO通过send()和emit()中的可选参数broadcast=True来支持这个特性:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(data)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, data, broadcast=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>当broadcast选项为True情况下发送消息，所有连接同个命名空间的客户端连接将收到这个消息，包括发送者。没有指定命名空间时，连接到全局命名空间的客户端将受到消息。注意广播消息不会调用回调函数。</p>
<p>上面所有例子都建立在服务端收到客户端的事件，但是有些应用服务端需要是消息的发起者。这对实现服务端发送通知给客户端很有用，比如在后台线程中。socketio.send()和socketio.emit()方法可以对所有连接的客户端广播：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_function</span><span class="params">()</span>:</span></span><br><span class="line">    socketio.emit(<span class="string">'some event'</span>, &#123;<span class="string">'data'</span>: <span class="number">42</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>注意在上下文感知上，socketio.send()和socketio.emit()是不一样的函数。也要注意上面没有客户端上下文的用法,所以broadcast=True是假定的并且不需要特指。</p>
<h2 id="Rooms-房间"><a href="#Rooms-房间" class="headerlink" title="Rooms(房间)"></a>Rooms(房间)</h2><p>对于很多应用对用户分组成子集并在子集中互相通信是必要的。很好的一个例子是多房间的聊天室，这里用户收到来自一个或多个他们进入的房间，但是不会收到另外房间的消息。Flask-SocketIO通过join_room()和leave_room()来支持房间概念:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> join_room, leave_room</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('join')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_join</span><span class="params">(data)</span>:</span></span><br><span class="line">    username = data[<span class="string">'username'</span>]</span><br><span class="line">    room = data[<span class="string">'room'</span>]</span><br><span class="line">    join_room(room)</span><br><span class="line">    send(username + <span class="string">' has entered the room.'</span>, room=room)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('leave')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_leave</span><span class="params">(data)</span>:</span></span><br><span class="line">    username = data[<span class="string">'username'</span>]</span><br><span class="line">    room = data[<span class="string">'room'</span>]</span><br><span class="line">    leave_room(room)</span><br><span class="line">    send(username + <span class="string">' has left the room.'</span>, room=room)</span><br></pre></td></tr></table></figure>
<p>send()和emit()函数接受可选参数room来控制消息发送给指定room的所有用户。</p>
<p>所有客户端在连接时赋值一个房间，名字使用连接的session ID，通过request.sid获得。客户端可以加入任何房间，房间可以起任何名称。当客户端断开连接，它将从进入过的房间移除。上下文无关socketio.send()和socketio.emit()函数也同样接受room参数来对一个房间进行广播</p>
<p>由于所有客户端分配到个人房间，给单个客户端发消息，客户端的session ID可以用来做room参数</p>
<h2 id="Connection-Events-连接事件"><a href="#Connection-Events-连接事件" class="headerlink" title="Connection Events(连接事件)"></a>Connection Events(连接事件)</h2><p>Flask-SocketIO也派遣连接和断开连接事件。下面例子展示如何为它们注册处理函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('connect', namespace='/chat')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_connect</span><span class="params">()</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, &#123;<span class="string">'data'</span>: <span class="string">'Connected'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('disconnect', namespace='/chat')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_disconnect</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Client disconnected'</span>)</span><br></pre></td></tr></table></figure>
<p>connection事件处理函数可以返回False来拒绝连接，这里便于客户端在这里权限校验<br>注意connection和disconnection事件在每个命名空间独立发送</p>
<h2 id="Class-Based-Namespaces-基于类的命名空间"><a href="#Class-Based-Namespaces-基于类的命名空间" class="headerlink" title="Class-Based Namespaces(基于类的命名空间)"></a>Class-Based Namespaces(基于类的命名空间)</h2><p>一种是上面描述的基于装饰器的事件处理，另一种方式是创建类方法作为事件处理。flask_socketio.Namespace作为基类来创建一个基于类的命名空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> Namespace, emit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomNamespace</span><span class="params">(Namespace)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_disconnect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_my_event</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        emit(<span class="string">'my_response'</span>, data)</span><br><span class="line">socketio.on_namespace(MyCustomNamespace(<span class="string">'/test'</span>))</span><br></pre></td></tr></table></figure>
<p>当基于类的命名空间被启用，任何被服务端收到的事件将派遣到方法名是以事件名加on_为前缀的方法中。举个例子，事件my_event将被方法名为on_my_event处理。如果收到一个事件在类命名空间中没有对应的方法，那么事件将被忽略。所有使用命名空间类的事件名必须使用方法名合法的字符。</p>
<blockquote>
<p>[原文]As a convenience to methods defined in a class-based namespace, the namespace instance includes versions of several of the methods in the flask_socketio.SocketIO class that default to the proper namespace when the namespace argument is not given.</p>
</blockquote>
<p>如果一个事件即有命名空间类的处理方法也有装饰器处理函数，那么只有装饰器处理函数被调用。</p>
<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><p>Flask-SocketIO也可以处理异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on_error()        # Handles the default namespace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_handler</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on_error('/chat') # handles the '/chat' namespace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_handler_chat</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on_error_default  # handles all namespaces without an explicit error handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_error_handler</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>错误处理函数将异常对象作为一个参数</p>
<p>当前请求的消息和数据参数可以通过request.event变量来检查，这有利于外部活动处理函数的错误日志和调试:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on("my error event")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_my_event</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> RuntimeError()</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on_error_default</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_error_handler</span><span class="params">(e)</span>:</span></span><br><span class="line">    print(request.event[<span class="string">"message"</span>]) <span class="comment"># "my error event"</span></span><br><span class="line">    print(request.event[<span class="string">"args"</span>])    <span class="comment"># (data,)</span></span><br></pre></td></tr></table></figure>

<h2 id="Access-to-Flask’s-Context-Globals-访问Flask的全局上下文"><a href="#Access-to-Flask’s-Context-Globals-访问Flask的全局上下文" class="headerlink" title="Access to Flask’s Context Globals(访问Flask的全局上下文)"></a>Access to Flask’s Context Globals(访问Flask的全局上下文)</h2><p>SocketIO事件处理函数不同于路由处理函数，这里介绍SocketIO处理函数中在哪些能做哪些不能做中容易混淆的东西。最主要的不同是所有SocketIO事件发生在单个长期运行的上下文请求之中。</p>
<p>尽管不同，但Flask-SocketIO尝试使SocketIO事件处理和常规HTTP请求的环境相似。下面描述了哪些还能正常工作，哪些不能了：</p>
<ul>
<li>在事件处理函数之前,应用上下文被压入（保存在数据结构中）使得current_app和g可以在处理函数中可用。</li>
<li>在调用处理函数之前请求上下文也被压入，同样使得request和session可用。但是注意WebSocket事件没有与之相关联的请求，所以对于在存活的连接中所有被派遣的事件请求上下文是在开始连接的时候被压入。</li>
<li>请求上下文(全局变量request)被连接产生的唯一session ID设置的sid变量所增强(request全局变量里增加了sid,http请求中是没有sid的)。这个值被用来初始化客户端加入的房间(room)。</li>
<li>请求上下文被含有命名空间和事件参数的namespace和event成员所增强(request中增加了namespace和event变量)。event成员是一个含有message和args的字典。</li>
<li>全局上下文变量<code>session</code>行为和常规的请求不一样。在SocketIO建立使处理函数在连接上下文中被调用的时候用户session被拷贝了一份。如果SocketIO处理函数修改了session，被修改的session变量将会被后续SocketIO处理函数有效，但是常规HTTP路由的处理函数看不到修改的变化。实际上，当SocketIO处理函数修改session，session的副本将被创建用于这些处理函数。这种限制的技术原因是，为了保存用户会话，需要将cookie发送到客户机，这需要HTTP请求和响应，而SocketIO连接中不存在这样的请求和响应。当使用诸如Flask-Session或Flask-KVSession扩展提供的服务器端会话时，只要会话没有在SocketIO处理程序中修改，SocketIO处理程序就可以看到HTTP路由处理程序中对会话所做的更改。</li>
<li>before_request和after_request钩子在SocketIO事件处理中无效。</li>
<li>SocketIO处理函数可以使用自定义的装饰器，但是许多Flask装饰器不能用在SocketIO处理函数上，在SocketIO连接中没有响应对象这个概念。</li>
</ul>
<h2 id="Authentication-验证"><a href="#Authentication-验证" class="headerlink" title="Authentication(验证)"></a>Authentication(验证)</h2><p>应用的共同需要就是验证他们用户的身份。自从SocketIO没有使用HTTP请求和应答，传统的基于网页表单和HTTP请求的机制不能用于SocketIO连接。如果需要的话，应用可以实施自定义的登陆表单，当用户按下提交按钮时，它利用一个SocketIO消息将证书发送到服务器。</p>
<p>然而，在大多数情况下，在SocketIO连接建立之前使用传统的身份验证方式会更加方便，用户的身份信息可以被记录下来作为用户会话或者cookie，之后在SocketIO连接建立起来的时候，这些信息也可以被SocketIO活动处理器得到。</p>
<h2 id="使用带有Flask-SocketIO的Flask-Login"><a href="#使用带有Flask-SocketIO的Flask-Login" class="headerlink" title="使用带有Flask-SocketIO的Flask-Login"></a>使用带有Flask-SocketIO的Flask-Login</h2><p>Flask-SocketIO可以访问被<a href="https://flask-login.readthedocs.org/en/latest/" target="_blank" rel="noopener">Flask-Login</a>维护的登录信息。Flask-Login鉴定执行和<code>login_user()</code>函数调用来在用户session中记录用户后，任何SocketIO连接将可以访问<code>current_user</code>上下文比变量:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@socketio.on('connect')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect_handler</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> current_user.is_authenticated:</span><br><span class="line">        emit(<span class="string">'my response'</span>,</span><br><span class="line">             &#123;<span class="string">'message'</span>: <span class="string">'&#123;0&#125; has joined'</span>.format(current_user.name)&#125;,</span><br><span class="line">             broadcast=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># not allowed here</span></span><br></pre></td></tr></table></figure>

<p>注意<code>login_required</code>装饰器不能用于SocketIO事件处理器,但是自定义一个无权限断开连接的装饰器如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> flask_login <span class="keyword">import</span> current_user</span><br><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> disconnect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticated_only</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> current_user.is_authenticated:</span><br><span class="line">            disconnect()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('my event')</span></span><br><span class="line"><span class="meta">@authenticated_only</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_my_custom_event</span><span class="params">(data)</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, &#123;<span class="string">'message'</span>: <span class="string">'&#123;0&#125; has joined'</span>.format(current_user.name)&#125;,</span><br><span class="line">         broadcast=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Deployment-部署"><a href="#Deployment-部署" class="headerlink" title="Deployment(部署)"></a>Deployment(部署)</h2><h3 id="Using-nginx-as-a-WebSocket-Reverse-Proxy-使用nginx作为WebSocket反向代理"><a href="#Using-nginx-as-a-WebSocket-Reverse-Proxy-使用nginx作为WebSocket反向代理" class="headerlink" title="Using nginx as a WebSocket Reverse Proxy(使用nginx作为WebSocket反向代理)"></a>Using nginx as a WebSocket Reverse Proxy(使用nginx作为WebSocket反向代理)</h3><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><h2 id="Using-Multiple-Workers-使用多个工作者"><a href="#Using-Multiple-Workers-使用多个工作者" class="headerlink" title="Using Multiple Workers(使用多个工作者)"></a>Using Multiple Workers(使用多个工作者)</h2><p>Flask-SocketIO从2.0版本开始在负载均衡器后面支持多个Worker(工作者).部署多个worker给Flask-SocketIO应用有能力在多个进程和主机上传播客户端连接,也因此可以支持更多的客户端并发。</p>
<p>使用多工作者模式需要两个依赖:</p>
<ul>
<li>负载均衡器必须被配置成从一个客户端来的所有HTTP请求发送到同一个worker处理。这个有时被称为”sticky sessions”。对于nginx，用ip_hash直接实现会话保持。Gunicorn不能被用于多个工作者，因为它的负载均衡算法不支持粘滞会话(sticky sessions)。</li>
<li>因为每一个server只拥有客户端连接的子集，所以例如Redis或者RabbitMQ这样的消息队列被用来协同一些操作，例如broadcasting(广播)和rooms。（译者注：这个应该好理解，多个worker部署在不同机器上，就有可能一个room的连接分布在不同机器上，如果要对房间内得人进行广播，那么必然要有个介质用来协调）。</li>
</ul>
<p>当在消息队列下工作就需要安装下面这些依赖:</p>
<ul>
<li>对于Redis，redis包必须安装(pip install redis).</li>
<li>对于RabbitMQ,kombu包必须安装(pip install kombu)</li>
<li>对于其它支持Kombu的消息队列，查看<a href="http://docs.celeryproject.org/projects/kombu/en/latest/introduction.html#transport-comparison" target="_blank" rel="noopener">Kombu documentation</a>来确定依赖什么</li>
<li>如果消息队列用到eventlet或者gevent,那么通常也需要python标准库的猴子补丁来让消息队列包工作</li>
</ul>
<p>为了让Flask-SocketIO服务器们跑起来，你必须首先确保有个消息队列跑起来。为了让Socket.IO服务器跑起来并且连接上消息队列，需要SocketIO构造器中增加一个message_queue参数：<br><code>socketio = SocketIO(app, message_queue=&#39;redis://&#39;)</code><br>message_queue参数值是你使用的消息队列URL连接。如果redis消息队列和服务跑在同一个主机上，可以使用’redis://‘URL。同样的，RabbitMQ队列使用’amqp://‘。Kombu包里的<a href="http://docs.celeryproject.org/projects/kombu/en/latest/userguide/connections.html?highlight=urls#urls" target="_blank" rel="noopener">文档</a>有描述它支持的队列URL格式。</p>
<h2 id="Emitting-from-an-External-Process"><a href="#Emitting-from-an-External-Process" class="headerlink" title="Emitting from an External Process"></a>Emitting from an External Process</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[[<a href="https://www.jianshu.com/p/d81397edd2b1]]" target="_blank" rel="noopener">https://www.jianshu.com/p/d81397edd2b1]]</a></p>
<p>[[<a href="https://flask-socketio.readthedocs.io/en/latest/]]" target="_blank" rel="noopener">https://flask-socketio.readthedocs.io/en/latest/]]</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/5146554.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='https://music.163.com/#/song?id=234014'></li>
                        
                    
                        
                            <li title='2' data-url='https://music.163.com/#/song?id=1404906595'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
